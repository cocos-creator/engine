// absolute essential effects
export default [
  {
    "name": "builtin-particle",
    "techniques": [
      {"name":"add", "passes":[{"rasterizerState":{"cullMode":0}, "blendState":{"targets":[{"blend":true, "blendSrc":2, "blendDst":1, "blendSrcAlpha":2, "blendDstAlpha":1}]}, "program":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:add", "depthStencilState":{"depthTest":true, "depthWrite":false}, "properties":{"mainTexture":{"value":"grey", "type":28}, "mainTiling_Offset":{"value":[1, 1, 0, 0], "type":16}, "frameTile_velLenScale":{"value":[1, 1, 0, 0], "type":16}, "tintColor":{"value":[0.5, 0.5, 0.5, 0.5], "inspector":{"type":"color"}, "type":16}}}]}
    ],
    "shaders": [
      {
        "name": "builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:add",
        "hash": 3980882972,
        "glsl3": {
          "vert": `\nprecision mediump float;\nuniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n};\nuniform CCGlobal {\n  vec4 cc_time; \n  vec4 cc_screenSize; \n  vec4 cc_screenScale; \n  vec4 cc_nativeSize; \n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos; \n  vec4 cc_exposure; \n  vec4 cc_mainLitDir; \n  vec4 cc_mainLitColor; \n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nout vec2 uv;\nout vec4 color;\nvoid computeVertPos(inout vec4 pos, vec2 vertOffset\n#if CC_USE_BILLBOARD || CC_USE_VERTICAL_BILLBOARD\n  , mat4 view\n#endif\n#if CC_USE_STRETCHED_BILLBOARD\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float size\n  , float xIndex\n#endif\n) {\n#if CC_USE_BILLBOARD\n  vec3 camRight = normalize(vec3(view[0][0], view[1][0], view[2][0]));\n  vec3 camUp = normalize(vec3(view[0][1], view[1][1], view[2][1]));\n  pos.xyz += (camRight * vertOffset.x) + (camUp * vertOffset.y);\n#elif CC_USE_STRETCHED_BILLBOARD\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz));\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * size;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_USE_HORIZONTAL_BILLBOARD\n  vec3 camRight = vec3(1, 0, 0);\n  vec3 camUp = vec3(0, 0, -1);\n  pos.xyz += (camRight * vertOffset.x) + (camUp * vertOffset.y);\n#elif CC_USE_VERTICAL_BILLBOARD\n  vec3 camRight = normalize(vec3(view[0][0], view[1][0], view[2][0]));\n  vec3 camUp = vec3(0, 1, 0);\n  pos.xyz += (camRight * vertOffset.x) + (camUp * vertOffset.y);\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV(float frameIndex, vec2 vertIndex, vec2 frameTile) {\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n  \n  vertIndex.x = 1. - vertIndex.x;\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nvoid rotateCorner(inout vec2 corner, float angle) {\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nin vec3 a_position; \nin vec3 a_texCoord;  \nin vec2 a_texCoord1; \nin vec4 a_color;\n#if CC_USE_STRETCHED_BILLBOARD\nin vec3 a_color1; \n#endif\nvec4 lpvs_main() {\n  vec4 pos = vec4(a_position, 1);\n#if CC_USE_STRETCHED_BILLBOARD\n  vec4 velocity = vec4(a_color1.xyz, 0);\n#endif\n#if !CC_USE_WORLD_SPACE\n  pos = cc_matWorld * pos;\n  #if CC_USE_STRETCHED_BILLBOARD\n  velocity = cc_matWorld * velocity;\n  #endif\n#endif\n  vec2 cornerOffset = vec2((a_texCoord.xy - 0.5) * a_texCoord1.x);\n#if !CC_USE_STRETCHED_BILLBOARD\n  rotateCorner(cornerOffset, a_texCoord1.y);\n#endif\n  computeVertPos(pos, cornerOffset\n  #if CC_USE_BILLBOARD || CC_USE_VERTICAL_BILLBOARD\n    , cc_matView\n  #endif\n  #if CC_USE_STRETCHED_BILLBOARD\n    , cc_cameraPos.xyz\n    , velocity\n    , frameTile_velLenScale.z\n    , frameTile_velLenScale.w\n    , a_texCoord1.x\n    , a_texCoord.x\n  #endif\n  );\n  pos = cc_matViewProj * pos;\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }\n`,
          "frag": `\nprecision mediump float;\nuniform CCGlobal {\n  vec4 cc_time; \n  vec4 cc_screenSize; \n  vec4 cc_screenScale; \n  vec4 cc_nativeSize; \n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos; \n  vec4 cc_exposure; \n  vec4 cc_mainLitDir; \n  vec4 cc_mainLitColor; \n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nvec4 PostProcess(vec4 color)\n{\n#if CC_USE_HDR\n	color.rgb = mix(color.rgb, pow(color.rgb, vec3(2.2)) * cc_exposure.w, vec3(cc_exposure.z));\n#endif\n	return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nuniform FragConstants {\n  vec4 tintColor;\n};\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n  return PostProcess(col);\n}\nvec4 multiply () {\n  vec4 col;\n  vec4 texColor = texture(mainTexture, uv);\n  col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n  col.a = (1.0 - texColor.a) * (tintColor.a * color.a * 2.0);\n  return PostProcess(col);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }\n`
        },
        "glsl1": {
          "vert": `\nprecision mediump float;\nuniform vec4 mainTiling_Offset;\nuniform vec4 frameTile_velLenScale;\nuniform vec4 cc_time;\nuniform vec4 cc_screenSize;\nuniform vec4 cc_screenScale;\nuniform vec4 cc_nativeSize;\nuniform mat4 cc_matView;\nuniform mat4 cc_matViewInv;\nuniform mat4 cc_matProj;\nuniform mat4 cc_matProjInv;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matViewProjInv;\nuniform vec4 cc_cameraPos;\nuniform vec4 cc_exposure;\nuniform vec4 cc_mainLitDir;\nuniform vec4 cc_mainLitColor;\nuniform vec4 cc_ambientSky;\nuniform vec4 cc_ambientGround;\nuniform mat4 cc_matWorld;\nuniform mat4 cc_matWorldIT;\nvarying vec2 uv;\nvarying vec4 color;\nvoid computeVertPos(inout vec4 pos, vec2 vertOffset\n#if CC_USE_BILLBOARD || CC_USE_VERTICAL_BILLBOARD\n  , mat4 view\n#endif\n#if CC_USE_STRETCHED_BILLBOARD\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float size\n  , float xIndex\n#endif\n) {\n#if CC_USE_BILLBOARD\n  vec3 camRight = normalize(vec3(view[0][0], view[1][0], view[2][0]));\n  vec3 camUp = normalize(vec3(view[0][1], view[1][1], view[2][1]));\n  pos.xyz += (camRight * vertOffset.x) + (camUp * vertOffset.y);\n#elif CC_USE_STRETCHED_BILLBOARD\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz));\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * size;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_USE_HORIZONTAL_BILLBOARD\n  vec3 camRight = vec3(1, 0, 0);\n  vec3 camUp = vec3(0, 0, -1);\n  pos.xyz += (camRight * vertOffset.x) + (camUp * vertOffset.y);\n#elif CC_USE_VERTICAL_BILLBOARD\n  vec3 camRight = normalize(vec3(view[0][0], view[1][0], view[2][0]));\n  vec3 camUp = vec3(0, 1, 0);\n  pos.xyz += (camRight * vertOffset.x) + (camUp * vertOffset.y);\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV(float frameIndex, vec2 vertIndex, vec2 frameTile) {\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n  \n  vertIndex.x = 1. - vertIndex.x;\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nvoid rotateCorner(inout vec2 corner, float angle) {\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nattribute vec3 a_position; \nattribute vec3 a_texCoord;  \nattribute vec2 a_texCoord1; \nattribute vec4 a_color;\n#if CC_USE_STRETCHED_BILLBOARD\nattribute vec3 a_color1; \n#endif\nvec4 lpvs_main() {\n  vec4 pos = vec4(a_position, 1);\n#if CC_USE_STRETCHED_BILLBOARD\n  vec4 velocity = vec4(a_color1.xyz, 0);\n#endif\n#if !CC_USE_WORLD_SPACE\n  pos = cc_matWorld * pos;\n  #if CC_USE_STRETCHED_BILLBOARD\n  velocity = cc_matWorld * velocity;\n  #endif\n#endif\n  vec2 cornerOffset = vec2((a_texCoord.xy - 0.5) * a_texCoord1.x);\n#if !CC_USE_STRETCHED_BILLBOARD\n  rotateCorner(cornerOffset, a_texCoord1.y);\n#endif\n  computeVertPos(pos, cornerOffset\n  #if CC_USE_BILLBOARD || CC_USE_VERTICAL_BILLBOARD\n    , cc_matView\n  #endif\n  #if CC_USE_STRETCHED_BILLBOARD\n    , cc_cameraPos.xyz\n    , velocity\n    , frameTile_velLenScale.z\n    , frameTile_velLenScale.w\n    , a_texCoord1.x\n    , a_texCoord.x\n  #endif\n  );\n  pos = cc_matViewProj * pos;\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }\n`,
          "frag": `\nprecision mediump float;\nuniform vec4 cc_time;\nuniform vec4 cc_screenSize;\nuniform vec4 cc_screenScale;\nuniform vec4 cc_nativeSize;\nuniform mat4 cc_matView;\nuniform mat4 cc_matViewInv;\nuniform mat4 cc_matProj;\nuniform mat4 cc_matProjInv;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matViewProjInv;\nuniform vec4 cc_cameraPos;\nuniform vec4 cc_exposure;\nuniform vec4 cc_mainLitDir;\nuniform vec4 cc_mainLitColor;\nuniform vec4 cc_ambientSky;\nuniform vec4 cc_ambientGround;\nvec4 PostProcess(vec4 color)\n{\n#if CC_USE_HDR\n	color.rgb = mix(color.rgb, pow(color.rgb, vec3(2.2)) * cc_exposure.w, vec3(cc_exposure.z));\n#endif\n	return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nuniform vec4 tintColor;\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\n  return PostProcess(col);\n}\nvec4 multiply () {\n  vec4 col;\n  vec4 texColor = texture2D(mainTexture, uv);\n  col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n  col.a = (1.0 - texColor.a) * (tintColor.a * color.a * 2.0);\n  return PostProcess(col);\n}\nvoid main() { gl_FragColor = add(); }\n`
        },
        "builtins": {"globals":{"blocks":["CCGlobal"], "samplers":[]}, "locals":{"blocks":["CCLocal"], "samplers":[]}},
        "defines": [
          {"name":"CC_USE_BILLBOARD", "type":"boolean", "defines":[]},
          {"name":"CC_USE_STRETCHED_BILLBOARD", "type":"boolean", "defines":[]},
          {"name":"CC_USE_HORIZONTAL_BILLBOARD", "type":"boolean", "defines":[]},
          {"name":"CC_USE_VERTICAL_BILLBOARD", "type":"boolean", "defines":[]},
          {"name":"CC_USE_WORLD_SPACE", "type":"boolean", "defines":[]},
          {"name":"CC_USE_HDR", "type":"boolean", "defines":[]}
        ],
        "blocks": [
          {"name": "Constants", "size": 32, "defines": [], "binding": 0, "members": [
            {"name":"mainTiling_Offset", "type":16, "count":1, "size":16},
            {"name":"frameTile_velLenScale", "type":16, "count":1, "size":16}
          ]},
          {"name": "FragConstants", "size": 16, "defines": [], "binding": 1, "members": [
            {"name":"tintColor", "type":16, "count":1, "size":16}
          ]}
        ],
        "samplers": [
          {"name":"mainTexture", "type":28, "count":1, "defines":[], "binding":2}
        ],
        "dependencies": {}
      }
    ]
  },
  {
    "name": "builtin-skybox",
    "techniques": [
      {"passes":[{"rasterizerState":{"cullMode":0}, "program":"builtin-skybox|sky-vs:vert|sky-fs:frag", "priority":245, "depthStencilState":{"depthTest":true, "depthWrite":false}, "properties":{"cubeMap":{"value":"default-cube", "type":31}}}]}
    ],
    "shaders": [
      {
        "name": "builtin-skybox|sky-vs:vert|sky-fs:frag",
        "hash": 4057107537,
        "glsl3": {
          "vert": `\nprecision mediump float;\nin vec3 a_position;\nuniform CCGlobal {\n  vec4 cc_time; \n  vec4 cc_screenSize; \n  vec4 cc_screenScale; \n  vec4 cc_nativeSize; \n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos; \n  vec4 cc_exposure; \n  vec4 cc_mainLitDir; \n  vec4 cc_mainLitColor; \n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nout vec3 viewDir;\nvec4 vert () {\n  mat4 matViewRotOnly = mat4(mat3(cc_matView));\n  vec4 clipPos = cc_matProj * matViewRotOnly * vec4(a_position, 1.0);\n  viewDir = a_position;\n  vec4 pos = clipPos;\n  pos.z = clipPos.w * 0.99999;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }\n`,
          "frag": `\nprecision mediump float;\nin vec3 viewDir;\nuniform samplerCube cubeMap;\nvec3 unpackNormal(vec4 nmap) {\n  return nmap.xyz * 2.0 - 1.0;\n}\nvec3 unpackRGBE(vec4 rgbe) {\n    return rgbe.rgb * pow(2.0, rgbe.a * 255.0 - 128.0);\n}\nvec3 SRGBToLinear(vec3 gamma)\n{\n	return pow(gamma, vec3(2.2));\n	\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n	return pow(linear, vec3(0.454545));\n	\n}\nuniform CCGlobal {\n  vec4 cc_time; \n  vec4 cc_screenSize; \n  vec4 cc_screenScale; \n  vec4 cc_nativeSize; \n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos; \n  vec4 cc_exposure; \n  vec4 cc_mainLitDir; \n  vec4 cc_mainLitColor; \n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nvec4 PostProcess(vec4 color)\n{\n#if CC_USE_HDR\n	color.rgb = mix(color.rgb, pow(color.rgb, vec3(2.2)) * cc_exposure.w, vec3(cc_exposure.z));\n#endif\n	return color;\n}\nvec4 frag () {\n#if USE_RGBE_CUBEMAP\n    vec3 c = unpackRGBE(texture(cubeMap, viewDir));\n    c = LinearToSRGB(c / (1.0 + c));\n    vec4 o = vec4(c, 1.0);\n#else\n    vec4 o = texture(cubeMap, viewDir);\n#endif\n  return PostProcess(o);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }\n`
        },
        "glsl1": {
          "vert": `\nprecision mediump float;\nattribute vec3 a_position;\nuniform vec4 cc_time;\nuniform vec4 cc_screenSize;\nuniform vec4 cc_screenScale;\nuniform vec4 cc_nativeSize;\nuniform mat4 cc_matView;\nuniform mat4 cc_matViewInv;\nuniform mat4 cc_matProj;\nuniform mat4 cc_matProjInv;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matViewProjInv;\nuniform vec4 cc_cameraPos;\nuniform vec4 cc_exposure;\nuniform vec4 cc_mainLitDir;\nuniform vec4 cc_mainLitColor;\nuniform vec4 cc_ambientSky;\nuniform vec4 cc_ambientGround;\nvarying vec3 viewDir;\nvec4 vert () {\n  mat4 matViewRotOnly = mat4(mat3(cc_matView));\n  vec4 clipPos = cc_matProj * matViewRotOnly * vec4(a_position, 1.0);\n  viewDir = a_position;\n  vec4 pos = clipPos;\n  pos.z = clipPos.w * 0.99999;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }\n`,
          "frag": `\nprecision mediump float;\nvarying vec3 viewDir;\nuniform samplerCube cubeMap;\nvec3 unpackNormal(vec4 nmap) {\n  return nmap.xyz * 2.0 - 1.0;\n}\nvec3 unpackRGBE(vec4 rgbe) {\n    return rgbe.rgb * pow(2.0, rgbe.a * 255.0 - 128.0);\n}\nvec3 SRGBToLinear(vec3 gamma)\n{\n	return pow(gamma, vec3(2.2));\n	\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n	return pow(linear, vec3(0.454545));\n	\n}\nuniform vec4 cc_time;\nuniform vec4 cc_screenSize;\nuniform vec4 cc_screenScale;\nuniform vec4 cc_nativeSize;\nuniform mat4 cc_matView;\nuniform mat4 cc_matViewInv;\nuniform mat4 cc_matProj;\nuniform mat4 cc_matProjInv;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matViewProjInv;\nuniform vec4 cc_cameraPos;\nuniform vec4 cc_exposure;\nuniform vec4 cc_mainLitDir;\nuniform vec4 cc_mainLitColor;\nuniform vec4 cc_ambientSky;\nuniform vec4 cc_ambientGround;\nvec4 PostProcess(vec4 color)\n{\n#if CC_USE_HDR\n	color.rgb = mix(color.rgb, pow(color.rgb, vec3(2.2)) * cc_exposure.w, vec3(cc_exposure.z));\n#endif\n	return color;\n}\nvec4 frag () {\n#if USE_RGBE_CUBEMAP\n    vec3 c = unpackRGBE(textureCube(cubeMap, viewDir));\n    c = LinearToSRGB(c / (1.0 + c));\n    vec4 o = vec4(c, 1.0);\n#else\n    vec4 o = textureCube(cubeMap, viewDir);\n#endif\n  return PostProcess(o);\n}\nvoid main() { gl_FragColor = frag(); }\n`
        },
        "builtins": {"globals":{"blocks":["CCGlobal"], "samplers":[]}, "locals":{"blocks":[], "samplers":[]}},
        "defines": [
          {"name":"CC_USE_HDR", "type":"boolean", "defines":[]},
          {"name":"USE_RGBE_CUBEMAP", "type":"boolean", "defines":[]}
        ],
        "blocks": [],
        "samplers": [
          {"name":"cubeMap", "type":31, "count":1, "defines":[], "binding":0}
        ],
        "dependencies": {}
      }
    ]
  },
  {
    "name": "builtin-sprite",
    "techniques": [
      {"passes":[{"blendState":{"targets":[{"blend":true, "blendSrc":2, "blendDst":4, "blendDstAlpha":4}]}, "rasterizerState":{"cullMode":0}, "program":"builtin-sprite|sprite-vs:vert|sprite-fs:frag", "priority":244, "depthStencilState":{"depthTest":true, "depthWrite":false}, "properties":{"mainTexture":{"value":"white", "type":28}}}]}
    ],
    "shaders": [
      {
        "name": "builtin-sprite|sprite-vs:vert|sprite-fs:frag",
        "hash": 2011945171,
        "glsl3": {
          "vert": `\nprecision mediump float;\nuniform CCGlobal {\n  vec4 cc_time; \n  vec4 cc_screenSize; \n  vec4 cc_screenScale; \n  vec4 cc_nativeSize; \n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos; \n  vec4 cc_exposure; \n  vec4 cc_mainLitDir; \n  vec4 cc_mainLitColor; \n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nin vec3 a_position;\nin vec4 a_color;\nout vec4 color;\n#if USE_TEXTURE\nin vec2 a_texCoord;\nout vec2 uv0;\n#endif\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  pos = cc_matViewProj * pos;\n  #if USE_TEXTURE\n  uv0 = a_texCoord;\n  #endif\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }\n`,
          "frag": `\nprecision mediump float;\nuniform CCGlobal {\n  vec4 cc_time; \n  vec4 cc_screenSize; \n  vec4 cc_screenScale; \n  vec4 cc_nativeSize; \n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos; \n  vec4 cc_exposure; \n  vec4 cc_mainLitDir; \n  vec4 cc_mainLitColor; \n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nvec4 PostProcess(vec4 color)\n{\n#if CC_USE_HDR\n	color.rgb = mix(color.rgb, pow(color.rgb, vec3(2.2)) * cc_exposure.w, vec3(cc_exposure.z));\n#endif\n	return color;\n}\nin vec4 color;\n#if USE_TEXTURE\nin vec2 uv0;\nuniform sampler2D mainTexture;\n#endif\nvec4 frag () {\n  vec4 o = vec4(1, 1, 1, 1);\n  #if USE_TEXTURE\n  o *= texture(mainTexture, uv0);\n  #endif\n  o *= color;\n  return o;\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }\n`
        },
        "glsl1": {
          "vert": `\nprecision mediump float;\nuniform vec4 cc_time;\nuniform vec4 cc_screenSize;\nuniform vec4 cc_screenScale;\nuniform vec4 cc_nativeSize;\nuniform mat4 cc_matView;\nuniform mat4 cc_matViewInv;\nuniform mat4 cc_matProj;\nuniform mat4 cc_matProjInv;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matViewProjInv;\nuniform vec4 cc_cameraPos;\nuniform vec4 cc_exposure;\nuniform vec4 cc_mainLitDir;\nuniform vec4 cc_mainLitColor;\nuniform vec4 cc_ambientSky;\nuniform vec4 cc_ambientGround;\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 color;\n#if USE_TEXTURE\nattribute vec2 a_texCoord;\nvarying vec2 uv0;\n#endif\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  pos = cc_matViewProj * pos;\n  #if USE_TEXTURE\n  uv0 = a_texCoord;\n  #endif\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }\n`,
          "frag": `\nprecision mediump float;\nuniform vec4 cc_time;\nuniform vec4 cc_screenSize;\nuniform vec4 cc_screenScale;\nuniform vec4 cc_nativeSize;\nuniform mat4 cc_matView;\nuniform mat4 cc_matViewInv;\nuniform mat4 cc_matProj;\nuniform mat4 cc_matProjInv;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matViewProjInv;\nuniform vec4 cc_cameraPos;\nuniform vec4 cc_exposure;\nuniform vec4 cc_mainLitDir;\nuniform vec4 cc_mainLitColor;\nuniform vec4 cc_ambientSky;\nuniform vec4 cc_ambientGround;\nvec4 PostProcess(vec4 color)\n{\n#if CC_USE_HDR\n	color.rgb = mix(color.rgb, pow(color.rgb, vec3(2.2)) * cc_exposure.w, vec3(cc_exposure.z));\n#endif\n	return color;\n}\nvarying vec4 color;\n#if USE_TEXTURE\nvarying vec2 uv0;\nuniform sampler2D mainTexture;\n#endif\nvec4 frag () {\n  vec4 o = vec4(1, 1, 1, 1);\n  #if USE_TEXTURE\n  o *= texture2D(mainTexture, uv0);\n  #endif\n  o *= color;\n  return o;\n}\nvoid main() { gl_FragColor = frag(); }\n`
        },
        "builtins": {"globals":{"blocks":["CCGlobal"], "samplers":[]}, "locals":{"blocks":[], "samplers":[]}},
        "defines": [
          {"name":"USE_TEXTURE", "type":"boolean", "defines":[]},
          {"name":"CC_USE_HDR", "type":"boolean", "defines":[]}
        ],
        "blocks": [],
        "samplers": [
          {"name":"mainTexture", "type":28, "count":1, "defines":["USE_TEXTURE"], "binding":0}
        ],
        "dependencies": {}
      }
    ]
  },
  {
    "name": "builtin-standard",
    "techniques": [
      {"name":"opaque", "passes":[{"program":"builtin-standard|standard-vs:vert|standard-fs:frag", "properties":{"tilingOffset":{"value":[1, 1, 0, 0], "type":16}, "albedo":{"value":[1, 1, 1, 1], "inspector":{"type":"color"}, "type":16}, "albedoScale":{"value":[1, 1, 1, 0], "type":16}, "pbrParams":{"value":[0.8, 0.6, 0, 1], "type":16}, "pbrScale":{"value":[1, 1, 1, 1], "type":16}, "emissive":{"value":[1, 1, 1, 1], "inspector":{"type":"color"}, "type":16}, "emissiveScale":{"value":[1, 1, 1, 1], "type":16}, "albedoMap":{"value":"grey", "type":28}, "normalMap":{"value":"normal", "type":28}, "pbrMap":{"value":"grey", "type":28}, "emissiveMap":{"value":"grey", "type":28}, "envMap":{"value":"default-cube", "type":31}}}, {"customizations":["bounds-merge-shadow"], "blendState":{"targets":[{"blend":true, "blendSrc":2, "blendDst":4, "blendDstAlpha":4}]}, "program":"builtin-standard|planar-shadow-vs:vert|planar-shadow-fs:frag", "depthStencilState":{"depthTest":true, "depthWrite":false, "stencilTestFront":true, "stencilFuncFront":5, "stencilPassOpFront":2, "stencilWriteMaskBack":128, "stencilWriteMaskFront":128, "stencilReadMaskBack":128, "stencilReadMaskFront":128, "stencilRefBack":128, "stencilRefFront":128}, "switch":"USE_PLANAR_SHADOW"}]}
    ],
    "shaders": [
      {
        "name": "builtin-standard|standard-vs:vert|standard-fs:frag",
        "hash": 1112283789,
        "glsl3": {
          "vert": `\n  precision mediump float;\nuniform CCGlobal {\n  vec4 cc_time; \n  vec4 cc_screenSize; \n  vec4 cc_screenScale; \n  vec4 cc_nativeSize; \n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos; \n  vec4 cc_exposure; \n  vec4 cc_mainLitDir; \n  vec4 cc_mainLitColor; \n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nuniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScale;   \n  vec4 pbrParams;     \n  vec4 pbrScale;      \n  vec4 emissive;\n  vec4 emissiveScale;\n};\n  #if CC_USE_SKINNING\nin vec4 a_weights;\nin vec4 a_joints;\n#if CC_USE_JOINTS_TEXTURE\n  \n  uniform CCSkinningTextureCase {\n    vec4 cc_jointsTextureSize;\n  };\n#else\n  \n  uniform CCSkinning {\n    vec4 cc_matJoint[65 * 3];\n  };\n#endif\n#if CC_USE_JOINTS_TEXTURE\nuniform sampler2D cc_jointsTexture;\n#if CC_USE_JOINTS_TEXTURE_RGBA8888\nhighp float decode32(highp vec4 rgba) {\n    highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;\n    highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;\n    if (Exponent == -127.0) {\n        return 0.0;\n    }\n    highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);\n    return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nhighp vec4 decodevec4 (highp vec4 x, highp vec4 y, highp vec4 z, highp vec4 w) {\n    return vec4(\n        decode32(x * 255.0),\n        decode32(y * 255.0),\n        decode32(z * 255.0),\n        decode32(w * 255.0)\n    );\n}\nhighp mat4 getBoneMatrix(const in float i) {\n  float size = cc_jointsTextureSize.x;\n  float j = i * 16.0;\n  float x = mod(j, size);\n  float y = floor(j / size);\n  float dx = 1.0 / size;\n  float dy = 1.0 / size;\n  y = dy * (y + 0.5);\n  highp vec4 v1 = decodevec4(\n      texture(cc_jointsTexture, vec2(dx * (x + 0.5), y)),\n      texture(cc_jointsTexture, vec2(dx * (x + 1.5), y)),\n      texture(cc_jointsTexture, vec2(dx * (x + 2.5), y)),\n      texture(cc_jointsTexture, vec2(dx * (x + 3.5), y))\n  );\n  highp vec4 v2 = decodevec4(\n      texture(cc_jointsTexture, vec2(dx * (x + 4.5), y)),\n      texture(cc_jointsTexture, vec2(dx * (x + 5.5), y)),\n      texture(cc_jointsTexture, vec2(dx * (x + 6.5), y)),\n      texture(cc_jointsTexture, vec2(dx * (x + 7.5), y))\n  );\n  highp vec4 v3 = decodevec4(\n      texture(cc_jointsTexture, vec2(dx * (x + 8.5), y)),\n      texture(cc_jointsTexture, vec2(dx * (x + 9.5), y)),\n      texture(cc_jointsTexture, vec2(dx * (x + 10.5), y)),\n      texture(cc_jointsTexture, vec2(dx * (x + 11.5), y))\n  );\n  highp vec4 v4 = decodevec4(\n      texture(cc_jointsTexture, vec2(dx * (x + 12.5), y)),\n      texture(cc_jointsTexture, vec2(dx * (x + 13.5), y)),\n      texture(cc_jointsTexture, vec2(dx * (x + 14.5), y)),\n      texture(cc_jointsTexture, vec2(dx * (x + 15.5), y))\n  );\n  return mat4(v1, v2, v3, v4);\n}\n#else\nmat4 getBoneMatrix(const in float i) {\n  float size = cc_jointsTextureSize.x;\n  float j = i * 4.0;\n  float x = mod(j, size);\n  float y = floor(j / size);\n  float dx = 1.0 / size;\n  float dy = 1.0 / size;\n  y = dy * (y + 0.5);\n  vec4 v1 = texture(cc_jointsTexture, vec2(dx * (x + 0.5), y));\n  vec4 v2 = texture(cc_jointsTexture, vec2(dx * (x + 1.5), y));\n  vec4 v3 = texture(cc_jointsTexture, vec2(dx * (x + 2.5), y));\n  vec4 v4 = texture(cc_jointsTexture, vec2(dx * (x + 3.5), y));\n  return mat4(v1, v2, v3, v4);\n}\n#endif\n#if CC_BINDPOSE_COMPUTATION_DEFERED\n  highp mat4 skinMatrix() {\n    return\n      getBoneMatrix(a_joints.x * 2.0 + 1.0) * getBoneMatrix(a_joints.x * 2.0 + 0.0) * a_weights.x +\n      getBoneMatrix(a_joints.y * 2.0 + 1.0) * getBoneMatrix(a_joints.y * 2.0 + 0.0) * a_weights.y +\n      getBoneMatrix(a_joints.z * 2.0 + 1.0) * getBoneMatrix(a_joints.z * 2.0 + 0.0) * a_weights.z +\n      getBoneMatrix(a_joints.w * 2.0 + 1.0) * getBoneMatrix(a_joints.w * 2.0 + 0.0) * a_weights.w;\n  }\n#else\n  highp mat4 skinMatrix() {\n    return\n      getBoneMatrix(a_joints.x) * a_weights.x +\n      getBoneMatrix(a_joints.y) * a_weights.y +\n      getBoneMatrix(a_joints.z) * a_weights.z +\n      getBoneMatrix(a_joints.w) * a_weights.w;\n  }\n#endif\n#else\nmat4 getBoneMatrix(const in float i) {\n  vec4 _0 = cc_matJoint[3 * int(i) + 0];\n  vec4 _1 = cc_matJoint[3 * int(i) + 1];\n  vec4 _2 = cc_matJoint[3 * int(i) + 2];\n  return mat4(\n      vec4(_0.x, _0.y, _0.z, 0),\n      vec4(_0.w, _1.x, _1.y, 0),\n      vec4(_1.z, _1.w, _2.x, 0),\n      vec4(_2.y, _2.z, _2.w, 1)\n  );\n}\nmat4 skinMatrix() {\n  return\n    getBoneMatrix(a_joints.x) * a_weights.x +\n    getBoneMatrix(a_joints.y) * a_weights.y +\n    getBoneMatrix(a_joints.z) * a_weights.z +\n    getBoneMatrix(a_joints.w) * a_weights.w;\n}\n#endif\nvoid skinVertex(inout highp vec4 a1) {\n  highp mat4 m = skinMatrix();\n  a1 = m * a1;\n}\nvoid skinVertex(inout highp vec4 a1, inout vec4 a2) {\n  highp mat4 m = skinMatrix();\n  a1 = m * a1;\n  a2 = m * a2;\n}\nvoid skinVertex(inout highp vec4 a1, inout vec4 a2, inout vec4 a3) {\n  highp mat4 m = skinMatrix();\n  a1 = m * a1;\n  a2 = m * a2;\n  a3 = m * a3;\n}\n  #endif\n  in vec3 a_position;\n  in vec3 a_normal;\n  in vec4 a_tangent;\n  out vec3 v_worldPos;\n  out vec3 v_worldNormal;\n  #if USE_ALBEDO_MAP || USE_NORMAL_MAP || USE_PBR_MAP || USE_EMISSIVE_MAP\n    in vec2 a_texCoord;\n    out vec2 v_uv;\n  #endif\n  #if USE_NORMAL_MAP\n    out vec3 v_tangent;\n  #endif\n  vec4 vert () {\n#if CC_USE_SKINNING\n    highp\n#endif\n    vec4 pos = vec4(a_position, 1.0);\n    vec4 normal = vec4(a_normal, 0.0);\n    #if CC_USE_SKINNING\n      skinVertex(pos, normal);\n    #else\n      pos = cc_matWorld * pos;\n      normal = cc_matWorldIT * normal;\n    #endif\n    v_worldPos = pos.xyz;\n    v_worldNormal = normal.xyz;\n    #if USE_ALBEDO_MAP || USE_NORMAL_MAP || USE_PBR_MAP || USE_EMISSIVE_MAP\n      v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n    #endif\n    #if USE_NORMAL_MAP\n      v_tangent = (cc_matWorldIT * vec4(a_tangent.xyz, 0.0)).xyz;\n    #endif\n    return cc_matViewProj * pos;\n  }\nvoid main() { gl_Position = vert(); }\n`,
          "frag": `\nprecision mediump float;\nuniform CCGlobal {\n  vec4 cc_time; \n  vec4 cc_screenSize; \n  vec4 cc_screenScale; \n  vec4 cc_nativeSize; \n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos; \n  vec4 cc_exposure; \n  vec4 cc_mainLitDir; \n  vec4 cc_mainLitColor; \n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\n#define MAX_LIGHTS 2\nuniform CCForwardLight {\n  vec4 cc_sphereLitPos[2]; \n  vec4 cc_sphereLitSizeRange[2]; \n  vec4 cc_sphereLitColor[2]; \n  vec4 cc_spotLitPos[2]; \n  vec4 cc_spotLitSizeRangeAngle[2]; \n  vec4 cc_spotLitDir[2]; \n  vec4 cc_spotLitColor[2]; \n};\n#define PI 3.14159265359\n#define PI2 6.28318530718\n#define EPSILON 1e-6\n#define LOG2 1.442695\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define FP_MAX          65504.0\n#define FP_SCALE        0.0009765625\n#define FP_SCALE_INV    1024.0\nvec3 SRGBToLinear(vec3 gamma)\n{\n	return pow(gamma, vec3(2.2));\n	\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n	return pow(linear, vec3(0.454545));\n	\n}\nfloat SmoothDistAtt2(float distSqr, float invSqrAttRadius)\n{\n	float factor = distSqr * invSqrAttRadius;	\n	float factor2 = factor * factor;			\n	float factor3 = factor2 * factor2;			\n	float smoothFactor = clamp(1.0 - factor3 * factor3, 0.0, 1.0);\n	return smoothFactor * smoothFactor;\n}\nfloat SmoothDistAtt(float distSqr, float invSqrAttRadius)\n{\n	float factor = distSqr * invSqrAttRadius;\n	float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n	return smoothFactor * smoothFactor;\n}\nfloat GetDistAtt(float distSqr, float invSqrAttRadius)\n{\n	float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n	attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n	return attenuation;\n}\nfloat GetAngleAtt(vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset)\n{\n	float cd = dot(litDir, L);\n	float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n	return (attenuation * attenuation);\n}\nfloat GGXMobile(float roughness, float NoH, vec3 H, vec3 N)\n{\n	vec3 NxH = cross(N, H);\n	float OneMinusNoHSqr = dot(NxH, NxH);\n	float a = roughness * roughness;\n	float n = NoH * a;\n	float p = a / (OneMinusNoHSqr + n * n);\n	return p * p;\n}\nfloat CalcSpecular(float roughness, float NoH, vec3 H, vec3 N)\n{\n	return (roughness*0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox(vec3 specular, float roughness, float NoV)\n{\n	const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n	const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n	vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n	AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n	return specular * AB.x + AB.y;\n}\nuniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScale;   \n  vec4 pbrParams;     \n  vec4 pbrScale;      \n  vec4 emissive;\n  vec4 emissiveScale;\n};\nin vec3 v_worldPos;\nin vec3 v_worldNormal;\n#if USE_ALBEDO_MAP || USE_NORMAL_MAP || USE_PBR_MAP || USE_EMISSIVE_MAP\n  in vec2 v_uv;\n#endif\n#if USE_NORMAL_MAP\n  in vec3 v_tangent;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#ifdef USE_IBL\n  uniform samplerCube envMap;\n#endif\nvec4 frag () {\n  #if USE_ALBEDO_MAP\n    vec4 baseColor = texture(albedoMap, v_uv) * albedo;\n  #else\n    vec4 baseColor = albedo;\n  #endif\n  baseColor.rgb *= albedoScale.rgb;\n  baseColor.rgb = SRGBToLinear(baseColor.rgb);\n  #if USE_ALPHA_TEST\n    if(baseColor.a < albedoScale.a)\n      discard;\n  #endif\n  vec3 N = normalize(v_worldNormal);\n  #if USE_NORMAL_MAP\n    vec3 normal = texture(normalMap, v_uv).rgb;\n    normal = 2.0 * normal.xyz - 1.0;\n    vec3 tangent = normalize(v_tangent);\n    vec3 binormal = normalize(cross(tangent, N));\n    mat3 matTBN = mat3(tangent, binormal, N);\n    N = normalize(matTBN * normal);\n  #endif\n  #if USE_PBR_MAP\n    vec4 pbr = texture(pbrMap, v_uv);\n  #else\n    vec4 pbr = pbrParams;\n  #endif\n  pbr *= pbrScale;\n  float roughness = clamp(pbr.ROUGHNESS_CHANNEL, 0.04, 1.0);\n  float metallic = clamp(pbr.METALLIC_CHANNEL, 0.0, 0.96);\n  vec3 diffuse = baseColor.rgb * (1.0 - metallic);\n  vec3 specular = mix(vec3(0.04), baseColor.rgb, metallic);\n  vec3 V = normalize(cc_cameraPos.xyz - v_worldPos);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L+V);\n  float NV = max(abs(dot(N, V)), 0.001);\n  float NL = max(dot(N, L), 0.001);\n  float NH = max(dot(N, H), 0.0);\n  specular = BRDFApprox(specular, roughness, NV);\n  vec3 specularContrib = specular * CalcSpecular(roughness, NH, H, N);\n  vec3 diffuseContrib = diffuse / 3.14159265359;\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w * (diffuseContrib + specularContrib);\n  for (int i = 0; i < 2; i++) {\n    \n    vec3 PLU = cc_sphereLitPos[i].xyz - v_worldPos;\n    vec3 PL = normalize(PLU);\n    vec3 PH = normalize(PL+V);\n    float PNL = max(dot(N, PL), 0.001);\n    float PNH = max(dot(N, PH), 0.0);\n    float distSqr = dot(PLU, PLU);\n    float litRadius = cc_sphereLitSizeRange[i].x;\n    float litRadiusSqr = litRadius * litRadius;\n    float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n    float attRadiusSqrInv = 1.0 / max(cc_sphereLitSizeRange[i].y, 0.01);\n    attRadiusSqrInv *= attRadiusSqrInv;\n    float att = GetDistAtt(distSqr, attRadiusSqrInv);\n    vec3 lspec = specular * CalcSpecular(roughness, PNH, PH, N);\n    finalColor += PNL * cc_sphereLitColor[i].rgb * cc_sphereLitColor[i].w * illum * att * (diffuseContrib + lspec);\n  }\n  for (int i = 0; i < 2; i++) {\n    \n    vec3 SLU = cc_spotLitPos[i].xyz - v_worldPos;\n    vec3 SL = normalize(SLU);\n    vec3 SH = normalize(SL+V);\n    float SNL = max(dot(N, SL), 0.001);\n    float SNH = max(dot(N, SH), 0.0);\n    float distSqr = dot(SLU, SLU);\n    float litRadius = cc_spotLitSizeRangeAngle[i].x;\n    float litRadiusSqr = litRadius * litRadius;\n    float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n    float attRadiusSqrInv = 1.0 / max(cc_spotLitSizeRangeAngle[i].y, 0.01);\n    attRadiusSqrInv *= attRadiusSqrInv;\n    float cosInner = max(dot(-cc_spotLitDir[i].xyz, SL), 0.01);\n    float cosOuter = cc_spotLitSizeRangeAngle[i].z;\n    float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n    float litAngleOffset = -cosOuter * litAngleScale;\n    float att = GetDistAtt(distSqr, attRadiusSqrInv);\n    att *= GetAngleAtt(SL, -cc_spotLitDir[i].xyz, litAngleScale, litAngleOffset);\n    vec3 lspec = specular * CalcSpecular(roughness, SNH, SH, N);\n    finalColor += SNL * cc_spotLitColor[i].rgb * cc_spotLitColor[i].w * illum * att * (diffuseContrib + lspec);\n  }\n  float fAmb = dot(N, vec3(0.0, -1.0, 0.0)) * 0.5 + 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\n  finalColor += (ambDiff.rgb * diffuse);\n  #if USE_IBL\n    vec3 R = normalize(reflect(-V, N));\n    vec4 env = texture(envMap, R);\n    env.rgb = SRGBToLinear(env.rgb) * cc_ambientSky.w;\n    finalColor += (env.rgb * specular);\n  #endif\n  finalColor = mix(finalColor, finalColor * pbr.AO_CHANNEL, pbrParams.z);\n  #if USE_EMISSIVE_MAP\n    vec3 emissiveColor = texture(emissiveMap, v_uv).rgb;\n    emissiveColor = SRGBToLinear(emissiveColor);\n  #if CC_USE_HDR\n    emissiveColor *= cc_exposure.w;\n  #endif\n    finalColor += emissiveColor * emissive.rgb * emissiveScale.xyz;\n  #endif\n  #if !CC_USE_HDR\n    finalColor = LinearToSRGB(finalColor);\n  #endif\n  return vec4(finalColor, baseColor.a);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }\n`
        },
        "glsl1": {
          "vert": `\n  precision mediump float;\nuniform vec4 cc_time;\nuniform vec4 cc_screenSize;\nuniform vec4 cc_screenScale;\nuniform vec4 cc_nativeSize;\nuniform mat4 cc_matView;\nuniform mat4 cc_matViewInv;\nuniform mat4 cc_matProj;\nuniform mat4 cc_matProjInv;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matViewProjInv;\nuniform vec4 cc_cameraPos;\nuniform vec4 cc_exposure;\nuniform vec4 cc_mainLitDir;\nuniform vec4 cc_mainLitColor;\nuniform vec4 cc_ambientSky;\nuniform vec4 cc_ambientGround;\nuniform mat4 cc_matWorld;\nuniform mat4 cc_matWorldIT;\nuniform vec4 tilingOffset;\nuniform vec4 albedo;\nuniform vec4 albedoScale;\nuniform vec4 pbrParams;\nuniform vec4 pbrScale;\nuniform vec4 emissive;\nuniform vec4 emissiveScale;\n  #if CC_USE_SKINNING\nattribute vec4 a_weights;\nattribute vec4 a_joints;\n#if CC_USE_JOINTS_TEXTURE\n  \n  uniform vec4 cc_jointsTextureSize;\n#else\n  \n  uniform vec4 cc_matJoint[195];\n#endif\n#if CC_USE_JOINTS_TEXTURE\nuniform sampler2D cc_jointsTexture;\n#if CC_USE_JOINTS_TEXTURE_RGBA8888\nhighp float decode32(highp vec4 rgba) {\n    highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;\n    highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;\n    if (Exponent == -127.0) {\n        return 0.0;\n    }\n    highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);\n    return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nhighp vec4 decodevec4 (highp vec4 x, highp vec4 y, highp vec4 z, highp vec4 w) {\n    return vec4(\n        decode32(x * 255.0),\n        decode32(y * 255.0),\n        decode32(z * 255.0),\n        decode32(w * 255.0)\n    );\n}\nhighp mat4 getBoneMatrix(const in float i) {\n  float size = cc_jointsTextureSize.x;\n  float j = i * 16.0;\n  float x = mod(j, size);\n  float y = floor(j / size);\n  float dx = 1.0 / size;\n  float dy = 1.0 / size;\n  y = dy * (y + 0.5);\n  highp vec4 v1 = decodevec4(\n      texture2D(cc_jointsTexture, vec2(dx * (x + 0.5), y)),\n      texture2D(cc_jointsTexture, vec2(dx * (x + 1.5), y)),\n      texture2D(cc_jointsTexture, vec2(dx * (x + 2.5), y)),\n      texture2D(cc_jointsTexture, vec2(dx * (x + 3.5), y))\n  );\n  highp vec4 v2 = decodevec4(\n      texture2D(cc_jointsTexture, vec2(dx * (x + 4.5), y)),\n      texture2D(cc_jointsTexture, vec2(dx * (x + 5.5), y)),\n      texture2D(cc_jointsTexture, vec2(dx * (x + 6.5), y)),\n      texture2D(cc_jointsTexture, vec2(dx * (x + 7.5), y))\n  );\n  highp vec4 v3 = decodevec4(\n      texture2D(cc_jointsTexture, vec2(dx * (x + 8.5), y)),\n      texture2D(cc_jointsTexture, vec2(dx * (x + 9.5), y)),\n      texture2D(cc_jointsTexture, vec2(dx * (x + 10.5), y)),\n      texture2D(cc_jointsTexture, vec2(dx * (x + 11.5), y))\n  );\n  highp vec4 v4 = decodevec4(\n      texture2D(cc_jointsTexture, vec2(dx * (x + 12.5), y)),\n      texture2D(cc_jointsTexture, vec2(dx * (x + 13.5), y)),\n      texture2D(cc_jointsTexture, vec2(dx * (x + 14.5), y)),\n      texture2D(cc_jointsTexture, vec2(dx * (x + 15.5), y))\n  );\n  return mat4(v1, v2, v3, v4);\n}\n#else\nmat4 getBoneMatrix(const in float i) {\n  float size = cc_jointsTextureSize.x;\n  float j = i * 4.0;\n  float x = mod(j, size);\n  float y = floor(j / size);\n  float dx = 1.0 / size;\n  float dy = 1.0 / size;\n  y = dy * (y + 0.5);\n  vec4 v1 = texture2D(cc_jointsTexture, vec2(dx * (x + 0.5), y));\n  vec4 v2 = texture2D(cc_jointsTexture, vec2(dx * (x + 1.5), y));\n  vec4 v3 = texture2D(cc_jointsTexture, vec2(dx * (x + 2.5), y));\n  vec4 v4 = texture2D(cc_jointsTexture, vec2(dx * (x + 3.5), y));\n  return mat4(v1, v2, v3, v4);\n}\n#endif\n#if CC_BINDPOSE_COMPUTATION_DEFERED\n  highp mat4 skinMatrix() {\n    return\n      getBoneMatrix(a_joints.x * 2.0 + 1.0) * getBoneMatrix(a_joints.x * 2.0 + 0.0) * a_weights.x +\n      getBoneMatrix(a_joints.y * 2.0 + 1.0) * getBoneMatrix(a_joints.y * 2.0 + 0.0) * a_weights.y +\n      getBoneMatrix(a_joints.z * 2.0 + 1.0) * getBoneMatrix(a_joints.z * 2.0 + 0.0) * a_weights.z +\n      getBoneMatrix(a_joints.w * 2.0 + 1.0) * getBoneMatrix(a_joints.w * 2.0 + 0.0) * a_weights.w;\n  }\n#else\n  highp mat4 skinMatrix() {\n    return\n      getBoneMatrix(a_joints.x) * a_weights.x +\n      getBoneMatrix(a_joints.y) * a_weights.y +\n      getBoneMatrix(a_joints.z) * a_weights.z +\n      getBoneMatrix(a_joints.w) * a_weights.w;\n  }\n#endif\n#else\nmat4 getBoneMatrix(const in float i) {\n  vec4 _0 = cc_matJoint[3 * int(i) + 0];\n  vec4 _1 = cc_matJoint[3 * int(i) + 1];\n  vec4 _2 = cc_matJoint[3 * int(i) + 2];\n  return mat4(\n      vec4(_0.x, _0.y, _0.z, 0),\n      vec4(_0.w, _1.x, _1.y, 0),\n      vec4(_1.z, _1.w, _2.x, 0),\n      vec4(_2.y, _2.z, _2.w, 1)\n  );\n}\nmat4 skinMatrix() {\n  return\n    getBoneMatrix(a_joints.x) * a_weights.x +\n    getBoneMatrix(a_joints.y) * a_weights.y +\n    getBoneMatrix(a_joints.z) * a_weights.z +\n    getBoneMatrix(a_joints.w) * a_weights.w;\n}\n#endif\nvoid skinVertex(inout highp vec4 a1) {\n  highp mat4 m = skinMatrix();\n  a1 = m * a1;\n}\nvoid skinVertex(inout highp vec4 a1, inout vec4 a2) {\n  highp mat4 m = skinMatrix();\n  a1 = m * a1;\n  a2 = m * a2;\n}\nvoid skinVertex(inout highp vec4 a1, inout vec4 a2, inout vec4 a3) {\n  highp mat4 m = skinMatrix();\n  a1 = m * a1;\n  a2 = m * a2;\n  a3 = m * a3;\n}\n  #endif\n  attribute vec3 a_position;\n  attribute vec3 a_normal;\n  attribute vec4 a_tangent;\n  varying vec3 v_worldPos;\n  varying vec3 v_worldNormal;\n  #if USE_ALBEDO_MAP || USE_NORMAL_MAP || USE_PBR_MAP || USE_EMISSIVE_MAP\n    attribute vec2 a_texCoord;\n    varying vec2 v_uv;\n  #endif\n  #if USE_NORMAL_MAP\n    varying vec3 v_tangent;\n  #endif\n  vec4 vert () {\n#if CC_USE_SKINNING\n    highp\n#endif\n    vec4 pos = vec4(a_position, 1.0);\n    vec4 normal = vec4(a_normal, 0.0);\n    #if CC_USE_SKINNING\n      skinVertex(pos, normal);\n    #else\n      pos = cc_matWorld * pos;\n      normal = cc_matWorldIT * normal;\n    #endif\n    v_worldPos = pos.xyz;\n    v_worldNormal = normal.xyz;\n    #if USE_ALBEDO_MAP || USE_NORMAL_MAP || USE_PBR_MAP || USE_EMISSIVE_MAP\n      v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n    #endif\n    #if USE_NORMAL_MAP\n      v_tangent = (cc_matWorldIT * vec4(a_tangent.xyz, 0.0)).xyz;\n    #endif\n    return cc_matViewProj * pos;\n  }\nvoid main() { gl_Position = vert(); }\n`,
          "frag": `\nprecision mediump float;\nuniform vec4 cc_time;\nuniform vec4 cc_screenSize;\nuniform vec4 cc_screenScale;\nuniform vec4 cc_nativeSize;\nuniform mat4 cc_matView;\nuniform mat4 cc_matViewInv;\nuniform mat4 cc_matProj;\nuniform mat4 cc_matProjInv;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matViewProjInv;\nuniform vec4 cc_cameraPos;\nuniform vec4 cc_exposure;\nuniform vec4 cc_mainLitDir;\nuniform vec4 cc_mainLitColor;\nuniform vec4 cc_ambientSky;\nuniform vec4 cc_ambientGround;\n#define MAX_LIGHTS 2\nuniform vec4 cc_sphereLitPos[2];\nuniform vec4 cc_sphereLitSizeRange[2];\nuniform vec4 cc_sphereLitColor[2];\nuniform vec4 cc_spotLitPos[2];\nuniform vec4 cc_spotLitSizeRangeAngle[2];\nuniform vec4 cc_spotLitDir[2];\nuniform vec4 cc_spotLitColor[2];\n#define PI 3.14159265359\n#define PI2 6.28318530718\n#define EPSILON 1e-6\n#define LOG2 1.442695\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define FP_MAX          65504.0\n#define FP_SCALE        0.0009765625\n#define FP_SCALE_INV    1024.0\nvec3 SRGBToLinear(vec3 gamma)\n{\n	return pow(gamma, vec3(2.2));\n	\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n	return pow(linear, vec3(0.454545));\n	\n}\nfloat SmoothDistAtt2(float distSqr, float invSqrAttRadius)\n{\n	float factor = distSqr * invSqrAttRadius;	\n	float factor2 = factor * factor;			\n	float factor3 = factor2 * factor2;			\n	float smoothFactor = clamp(1.0 - factor3 * factor3, 0.0, 1.0);\n	return smoothFactor * smoothFactor;\n}\nfloat SmoothDistAtt(float distSqr, float invSqrAttRadius)\n{\n	float factor = distSqr * invSqrAttRadius;\n	float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n	return smoothFactor * smoothFactor;\n}\nfloat GetDistAtt(float distSqr, float invSqrAttRadius)\n{\n	float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n	attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n	return attenuation;\n}\nfloat GetAngleAtt(vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset)\n{\n	float cd = dot(litDir, L);\n	float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n	return (attenuation * attenuation);\n}\nfloat GGXMobile(float roughness, float NoH, vec3 H, vec3 N)\n{\n	vec3 NxH = cross(N, H);\n	float OneMinusNoHSqr = dot(NxH, NxH);\n	float a = roughness * roughness;\n	float n = NoH * a;\n	float p = a / (OneMinusNoHSqr + n * n);\n	return p * p;\n}\nfloat CalcSpecular(float roughness, float NoH, vec3 H, vec3 N)\n{\n	return (roughness*0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox(vec3 specular, float roughness, float NoV)\n{\n	const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n	const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n	vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n	AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n	return specular * AB.x + AB.y;\n}\nuniform vec4 tilingOffset;\nuniform vec4 albedo;\nuniform vec4 albedoScale;\nuniform vec4 pbrParams;\nuniform vec4 pbrScale;\nuniform vec4 emissive;\nuniform vec4 emissiveScale;\nvarying vec3 v_worldPos;\nvarying vec3 v_worldNormal;\n#if USE_ALBEDO_MAP || USE_NORMAL_MAP || USE_PBR_MAP || USE_EMISSIVE_MAP\n  varying vec2 v_uv;\n#endif\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#ifdef USE_IBL\n  uniform samplerCube envMap;\n#endif\nvec4 frag () {\n  #if USE_ALBEDO_MAP\n    vec4 baseColor = texture2D(albedoMap, v_uv) * albedo;\n  #else\n    vec4 baseColor = albedo;\n  #endif\n  baseColor.rgb *= albedoScale.rgb;\n  baseColor.rgb = SRGBToLinear(baseColor.rgb);\n  #if USE_ALPHA_TEST\n    if(baseColor.a < albedoScale.a)\n      discard;\n  #endif\n  vec3 N = normalize(v_worldNormal);\n  #if USE_NORMAL_MAP\n    vec3 normal = texture2D(normalMap, v_uv).rgb;\n    normal = 2.0 * normal.xyz - 1.0;\n    vec3 tangent = normalize(v_tangent);\n    vec3 binormal = normalize(cross(tangent, N));\n    mat3 matTBN = mat3(tangent, binormal, N);\n    N = normalize(matTBN * normal);\n  #endif\n  #if USE_PBR_MAP\n    vec4 pbr = texture2D(pbrMap, v_uv);\n  #else\n    vec4 pbr = pbrParams;\n  #endif\n  pbr *= pbrScale;\n  float roughness = clamp(pbr.ROUGHNESS_CHANNEL, 0.04, 1.0);\n  float metallic = clamp(pbr.METALLIC_CHANNEL, 0.0, 0.96);\n  vec3 diffuse = baseColor.rgb * (1.0 - metallic);\n  vec3 specular = mix(vec3(0.04), baseColor.rgb, metallic);\n  vec3 V = normalize(cc_cameraPos.xyz - v_worldPos);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L+V);\n  float NV = max(abs(dot(N, V)), 0.001);\n  float NL = max(dot(N, L), 0.001);\n  float NH = max(dot(N, H), 0.0);\n  specular = BRDFApprox(specular, roughness, NV);\n  vec3 specularContrib = specular * CalcSpecular(roughness, NH, H, N);\n  vec3 diffuseContrib = diffuse / 3.14159265359;\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w * (diffuseContrib + specularContrib);\n  for (int i = 0; i < 2; i++) {\n    \n    vec3 PLU = cc_sphereLitPos[i].xyz - v_worldPos;\n    vec3 PL = normalize(PLU);\n    vec3 PH = normalize(PL+V);\n    float PNL = max(dot(N, PL), 0.001);\n    float PNH = max(dot(N, PH), 0.0);\n    float distSqr = dot(PLU, PLU);\n    float litRadius = cc_sphereLitSizeRange[i].x;\n    float litRadiusSqr = litRadius * litRadius;\n    float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n    float attRadiusSqrInv = 1.0 / max(cc_sphereLitSizeRange[i].y, 0.01);\n    attRadiusSqrInv *= attRadiusSqrInv;\n    float att = GetDistAtt(distSqr, attRadiusSqrInv);\n    vec3 lspec = specular * CalcSpecular(roughness, PNH, PH, N);\n    finalColor += PNL * cc_sphereLitColor[i].rgb * cc_sphereLitColor[i].w * illum * att * (diffuseContrib + lspec);\n  }\n  for (int i = 0; i < 2; i++) {\n    \n    vec3 SLU = cc_spotLitPos[i].xyz - v_worldPos;\n    vec3 SL = normalize(SLU);\n    vec3 SH = normalize(SL+V);\n    float SNL = max(dot(N, SL), 0.001);\n    float SNH = max(dot(N, SH), 0.0);\n    float distSqr = dot(SLU, SLU);\n    float litRadius = cc_spotLitSizeRangeAngle[i].x;\n    float litRadiusSqr = litRadius * litRadius;\n    float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n    float attRadiusSqrInv = 1.0 / max(cc_spotLitSizeRangeAngle[i].y, 0.01);\n    attRadiusSqrInv *= attRadiusSqrInv;\n    float cosInner = max(dot(-cc_spotLitDir[i].xyz, SL), 0.01);\n    float cosOuter = cc_spotLitSizeRangeAngle[i].z;\n    float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n    float litAngleOffset = -cosOuter * litAngleScale;\n    float att = GetDistAtt(distSqr, attRadiusSqrInv);\n    att *= GetAngleAtt(SL, -cc_spotLitDir[i].xyz, litAngleScale, litAngleOffset);\n    vec3 lspec = specular * CalcSpecular(roughness, SNH, SH, N);\n    finalColor += SNL * cc_spotLitColor[i].rgb * cc_spotLitColor[i].w * illum * att * (diffuseContrib + lspec);\n  }\n  float fAmb = dot(N, vec3(0.0, -1.0, 0.0)) * 0.5 + 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\n  finalColor += (ambDiff.rgb * diffuse);\n  #if USE_IBL\n    vec3 R = normalize(reflect(-V, N));\n    vec4 env = textureCube(envMap, R);\n    env.rgb = SRGBToLinear(env.rgb) * cc_ambientSky.w;\n    finalColor += (env.rgb * specular);\n  #endif\n  finalColor = mix(finalColor, finalColor * pbr.AO_CHANNEL, pbrParams.z);\n  #if USE_EMISSIVE_MAP\n    vec3 emissiveColor = texture2D(emissiveMap, v_uv).rgb;\n    emissiveColor = SRGBToLinear(emissiveColor);\n  #if CC_USE_HDR\n    emissiveColor *= cc_exposure.w;\n  #endif\n    finalColor += emissiveColor * emissive.rgb * emissiveScale.xyz;\n  #endif\n  #if !CC_USE_HDR\n    finalColor = LinearToSRGB(finalColor);\n  #endif\n  return vec4(finalColor, baseColor.a);\n}\nvoid main() { gl_FragColor = frag(); }\n`
        },
        "builtins": {"globals":{"blocks":["CCGlobal"], "samplers":[]}, "locals":{"blocks":["CCLocal", "CCSkinningTextureCase", "CCSkinning", "CCForwardLight"], "samplers":["cc_jointsTexture"]}},
        "defines": [
          {"name":"CC_USE_SKINNING", "type":"boolean", "defines":[]},
          {"name":"CC_USE_JOINTS_TEXTURE", "type":"boolean", "defines":["CC_USE_SKINNING"]},
          {"name":"CC_USE_JOINTS_TEXTURE_RGBA8888", "type":"boolean", "defines":["CC_USE_SKINNING", "CC_USE_JOINTS_TEXTURE"]},
          {"name":"CC_BINDPOSE_COMPUTATION_DEFERED", "type":"boolean", "defines":["CC_USE_SKINNING", "CC_USE_JOINTS_TEXTURE"]},
          {"name":"USE_ALBEDO_MAP", "type":"boolean", "defines":[]},
          {"name":"USE_NORMAL_MAP", "type":"boolean", "defines":[]},
          {"name":"USE_PBR_MAP", "type":"boolean", "defines":[]},
          {"name":"USE_EMISSIVE_MAP", "type":"boolean", "defines":[]},
          {"name":"USE_IBL", "type":"boolean", "defines":[]},
          {"name":"ROUGHNESS_CHANNEL", "type":"string", "options":["r", "g", "b", "a"]},
          {"name":"METALLIC_CHANNEL", "type":"string", "options":["g", "r", "b", "a"]},
          {"name":"AO_CHANNEL", "type":"string", "options":["b", "r", "g", "a"]},
          {"name":"USE_ALPHA_TEST", "type":"boolean", "defines":[]},
          {"name":"CC_USE_HDR", "type":"boolean", "defines":[]}
        ],
        "blocks": [
          {"name": "Constants", "size": 112, "defines": [], "binding": 0, "members": [
            {"name":"tilingOffset", "type":16, "count":1, "size":16},
            {"name":"albedo", "type":16, "count":1, "size":16},
            {"name":"albedoScale", "type":16, "count":1, "size":16},
            {"name":"pbrParams", "type":16, "count":1, "size":16},
            {"name":"pbrScale", "type":16, "count":1, "size":16},
            {"name":"emissive", "type":16, "count":1, "size":16},
            {"name":"emissiveScale", "type":16, "count":1, "size":16}
          ]}
        ],
        "samplers": [
          {"name":"albedoMap", "type":28, "count":1, "defines":["USE_ALBEDO_MAP"], "binding":1},
          {"name":"normalMap", "type":28, "count":1, "defines":["USE_NORMAL_MAP"], "binding":2},
          {"name":"pbrMap", "type":28, "count":1, "defines":["USE_PBR_MAP"], "binding":3},
          {"name":"emissiveMap", "type":28, "count":1, "defines":["USE_EMISSIVE_MAP"], "binding":4},
          {"name":"envMap", "type":31, "count":1, "defines":["USE_IBL"], "binding":5}
        ],
        "dependencies": {}
      },
      {
        "name": "builtin-standard|planar-shadow-vs:vert|planar-shadow-fs:frag",
        "hash": 2955095106,
        "glsl3": {
          "vert": `\n  precision mediump float;\nuniform CCGlobal {\n  vec4 cc_time; \n  vec4 cc_screenSize; \n  vec4 cc_screenScale; \n  vec4 cc_nativeSize; \n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos; \n  vec4 cc_exposure; \n  vec4 cc_mainLitDir; \n  vec4 cc_mainLitColor; \n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nuniform CCShadow {\n  mat4 cc_matLightPlaneProj;\n  vec4 cc_shadowColor;\n};\n  #if CC_USE_SKINNING\nin vec4 a_weights;\nin vec4 a_joints;\n#if CC_USE_JOINTS_TEXTURE\n  \n  uniform CCSkinningTextureCase {\n    vec4 cc_jointsTextureSize;\n  };\n#else\n  \n  uniform CCSkinning {\n    vec4 cc_matJoint[65 * 3];\n  };\n#endif\n#if CC_USE_JOINTS_TEXTURE\nuniform sampler2D cc_jointsTexture;\n#if CC_USE_JOINTS_TEXTURE_RGBA8888\nhighp float decode32(highp vec4 rgba) {\n    highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;\n    highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;\n    if (Exponent == -127.0) {\n        return 0.0;\n    }\n    highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);\n    return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nhighp vec4 decodevec4 (highp vec4 x, highp vec4 y, highp vec4 z, highp vec4 w) {\n    return vec4(\n        decode32(x * 255.0),\n        decode32(y * 255.0),\n        decode32(z * 255.0),\n        decode32(w * 255.0)\n    );\n}\nhighp mat4 getBoneMatrix(const in float i) {\n  float size = cc_jointsTextureSize.x;\n  float j = i * 16.0;\n  float x = mod(j, size);\n  float y = floor(j / size);\n  float dx = 1.0 / size;\n  float dy = 1.0 / size;\n  y = dy * (y + 0.5);\n  highp vec4 v1 = decodevec4(\n      texture(cc_jointsTexture, vec2(dx * (x + 0.5), y)),\n      texture(cc_jointsTexture, vec2(dx * (x + 1.5), y)),\n      texture(cc_jointsTexture, vec2(dx * (x + 2.5), y)),\n      texture(cc_jointsTexture, vec2(dx * (x + 3.5), y))\n  );\n  highp vec4 v2 = decodevec4(\n      texture(cc_jointsTexture, vec2(dx * (x + 4.5), y)),\n      texture(cc_jointsTexture, vec2(dx * (x + 5.5), y)),\n      texture(cc_jointsTexture, vec2(dx * (x + 6.5), y)),\n      texture(cc_jointsTexture, vec2(dx * (x + 7.5), y))\n  );\n  highp vec4 v3 = decodevec4(\n      texture(cc_jointsTexture, vec2(dx * (x + 8.5), y)),\n      texture(cc_jointsTexture, vec2(dx * (x + 9.5), y)),\n      texture(cc_jointsTexture, vec2(dx * (x + 10.5), y)),\n      texture(cc_jointsTexture, vec2(dx * (x + 11.5), y))\n  );\n  highp vec4 v4 = decodevec4(\n      texture(cc_jointsTexture, vec2(dx * (x + 12.5), y)),\n      texture(cc_jointsTexture, vec2(dx * (x + 13.5), y)),\n      texture(cc_jointsTexture, vec2(dx * (x + 14.5), y)),\n      texture(cc_jointsTexture, vec2(dx * (x + 15.5), y))\n  );\n  return mat4(v1, v2, v3, v4);\n}\n#else\nmat4 getBoneMatrix(const in float i) {\n  float size = cc_jointsTextureSize.x;\n  float j = i * 4.0;\n  float x = mod(j, size);\n  float y = floor(j / size);\n  float dx = 1.0 / size;\n  float dy = 1.0 / size;\n  y = dy * (y + 0.5);\n  vec4 v1 = texture(cc_jointsTexture, vec2(dx * (x + 0.5), y));\n  vec4 v2 = texture(cc_jointsTexture, vec2(dx * (x + 1.5), y));\n  vec4 v3 = texture(cc_jointsTexture, vec2(dx * (x + 2.5), y));\n  vec4 v4 = texture(cc_jointsTexture, vec2(dx * (x + 3.5), y));\n  return mat4(v1, v2, v3, v4);\n}\n#endif\n#if CC_BINDPOSE_COMPUTATION_DEFERED\n  highp mat4 skinMatrix() {\n    return\n      getBoneMatrix(a_joints.x * 2.0 + 1.0) * getBoneMatrix(a_joints.x * 2.0 + 0.0) * a_weights.x +\n      getBoneMatrix(a_joints.y * 2.0 + 1.0) * getBoneMatrix(a_joints.y * 2.0 + 0.0) * a_weights.y +\n      getBoneMatrix(a_joints.z * 2.0 + 1.0) * getBoneMatrix(a_joints.z * 2.0 + 0.0) * a_weights.z +\n      getBoneMatrix(a_joints.w * 2.0 + 1.0) * getBoneMatrix(a_joints.w * 2.0 + 0.0) * a_weights.w;\n  }\n#else\n  highp mat4 skinMatrix() {\n    return\n      getBoneMatrix(a_joints.x) * a_weights.x +\n      getBoneMatrix(a_joints.y) * a_weights.y +\n      getBoneMatrix(a_joints.z) * a_weights.z +\n      getBoneMatrix(a_joints.w) * a_weights.w;\n  }\n#endif\n#else\nmat4 getBoneMatrix(const in float i) {\n  vec4 _0 = cc_matJoint[3 * int(i) + 0];\n  vec4 _1 = cc_matJoint[3 * int(i) + 1];\n  vec4 _2 = cc_matJoint[3 * int(i) + 2];\n  return mat4(\n      vec4(_0.x, _0.y, _0.z, 0),\n      vec4(_0.w, _1.x, _1.y, 0),\n      vec4(_1.z, _1.w, _2.x, 0),\n      vec4(_2.y, _2.z, _2.w, 1)\n  );\n}\nmat4 skinMatrix() {\n  return\n    getBoneMatrix(a_joints.x) * a_weights.x +\n    getBoneMatrix(a_joints.y) * a_weights.y +\n    getBoneMatrix(a_joints.z) * a_weights.z +\n    getBoneMatrix(a_joints.w) * a_weights.w;\n}\n#endif\nvoid skinVertex(inout highp vec4 a1) {\n  highp mat4 m = skinMatrix();\n  a1 = m * a1;\n}\nvoid skinVertex(inout highp vec4 a1, inout vec4 a2) {\n  highp mat4 m = skinMatrix();\n  a1 = m * a1;\n  a2 = m * a2;\n}\nvoid skinVertex(inout highp vec4 a1, inout vec4 a2, inout vec4 a3) {\n  highp mat4 m = skinMatrix();\n  a1 = m * a1;\n  a2 = m * a2;\n  a3 = m * a3;\n}\n  #endif\n  in vec3 a_position;\n  vec4 vert () {\n#if CC_USE_SKINNING\n    highp\n#endif\n    vec4 pos = vec4(a_position, 1);\n    #if CC_USE_SKINNING\n      skinVertex(pos);\n    #else\n      pos = cc_matWorld * pos;\n    #endif\n    pos = cc_matViewProj * cc_matLightPlaneProj * pos;\n    pos.z -= 0.0001;\n    return pos;\n  }\nvoid main() { gl_Position = vert(); }\n`,
          "frag": `\nprecision mediump float;\nuniform CCShadow {\n  mat4 cc_matLightPlaneProj;\n  vec4 cc_shadowColor;\n};\nuniform CCGlobal {\n  vec4 cc_time; \n  vec4 cc_screenSize; \n  vec4 cc_screenScale; \n  vec4 cc_nativeSize; \n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos; \n  vec4 cc_exposure; \n  vec4 cc_mainLitDir; \n  vec4 cc_mainLitColor; \n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nvec4 PostProcess(vec4 color)\n{\n#if CC_USE_HDR\n	color.rgb = mix(color.rgb, pow(color.rgb, vec3(2.2)) * cc_exposure.w, vec3(cc_exposure.z));\n#endif\n	return color;\n}\nvec4 frag () {\n  return PostProcess(cc_shadowColor);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }\n`
        },
        "glsl1": {
          "vert": `\n  precision mediump float;\nuniform vec4 cc_time;\nuniform vec4 cc_screenSize;\nuniform vec4 cc_screenScale;\nuniform vec4 cc_nativeSize;\nuniform mat4 cc_matView;\nuniform mat4 cc_matViewInv;\nuniform mat4 cc_matProj;\nuniform mat4 cc_matProjInv;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matViewProjInv;\nuniform vec4 cc_cameraPos;\nuniform vec4 cc_exposure;\nuniform vec4 cc_mainLitDir;\nuniform vec4 cc_mainLitColor;\nuniform vec4 cc_ambientSky;\nuniform vec4 cc_ambientGround;\nuniform mat4 cc_matWorld;\nuniform mat4 cc_matWorldIT;\nuniform mat4 cc_matLightPlaneProj;\nuniform vec4 cc_shadowColor;\n  #if CC_USE_SKINNING\nattribute vec4 a_weights;\nattribute vec4 a_joints;\n#if CC_USE_JOINTS_TEXTURE\n  \n  uniform vec4 cc_jointsTextureSize;\n#else\n  \n  uniform vec4 cc_matJoint[195];\n#endif\n#if CC_USE_JOINTS_TEXTURE\nuniform sampler2D cc_jointsTexture;\n#if CC_USE_JOINTS_TEXTURE_RGBA8888\nhighp float decode32(highp vec4 rgba) {\n    highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;\n    highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;\n    if (Exponent == -127.0) {\n        return 0.0;\n    }\n    highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);\n    return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nhighp vec4 decodevec4 (highp vec4 x, highp vec4 y, highp vec4 z, highp vec4 w) {\n    return vec4(\n        decode32(x * 255.0),\n        decode32(y * 255.0),\n        decode32(z * 255.0),\n        decode32(w * 255.0)\n    );\n}\nhighp mat4 getBoneMatrix(const in float i) {\n  float size = cc_jointsTextureSize.x;\n  float j = i * 16.0;\n  float x = mod(j, size);\n  float y = floor(j / size);\n  float dx = 1.0 / size;\n  float dy = 1.0 / size;\n  y = dy * (y + 0.5);\n  highp vec4 v1 = decodevec4(\n      texture2D(cc_jointsTexture, vec2(dx * (x + 0.5), y)),\n      texture2D(cc_jointsTexture, vec2(dx * (x + 1.5), y)),\n      texture2D(cc_jointsTexture, vec2(dx * (x + 2.5), y)),\n      texture2D(cc_jointsTexture, vec2(dx * (x + 3.5), y))\n  );\n  highp vec4 v2 = decodevec4(\n      texture2D(cc_jointsTexture, vec2(dx * (x + 4.5), y)),\n      texture2D(cc_jointsTexture, vec2(dx * (x + 5.5), y)),\n      texture2D(cc_jointsTexture, vec2(dx * (x + 6.5), y)),\n      texture2D(cc_jointsTexture, vec2(dx * (x + 7.5), y))\n  );\n  highp vec4 v3 = decodevec4(\n      texture2D(cc_jointsTexture, vec2(dx * (x + 8.5), y)),\n      texture2D(cc_jointsTexture, vec2(dx * (x + 9.5), y)),\n      texture2D(cc_jointsTexture, vec2(dx * (x + 10.5), y)),\n      texture2D(cc_jointsTexture, vec2(dx * (x + 11.5), y))\n  );\n  highp vec4 v4 = decodevec4(\n      texture2D(cc_jointsTexture, vec2(dx * (x + 12.5), y)),\n      texture2D(cc_jointsTexture, vec2(dx * (x + 13.5), y)),\n      texture2D(cc_jointsTexture, vec2(dx * (x + 14.5), y)),\n      texture2D(cc_jointsTexture, vec2(dx * (x + 15.5), y))\n  );\n  return mat4(v1, v2, v3, v4);\n}\n#else\nmat4 getBoneMatrix(const in float i) {\n  float size = cc_jointsTextureSize.x;\n  float j = i * 4.0;\n  float x = mod(j, size);\n  float y = floor(j / size);\n  float dx = 1.0 / size;\n  float dy = 1.0 / size;\n  y = dy * (y + 0.5);\n  vec4 v1 = texture2D(cc_jointsTexture, vec2(dx * (x + 0.5), y));\n  vec4 v2 = texture2D(cc_jointsTexture, vec2(dx * (x + 1.5), y));\n  vec4 v3 = texture2D(cc_jointsTexture, vec2(dx * (x + 2.5), y));\n  vec4 v4 = texture2D(cc_jointsTexture, vec2(dx * (x + 3.5), y));\n  return mat4(v1, v2, v3, v4);\n}\n#endif\n#if CC_BINDPOSE_COMPUTATION_DEFERED\n  highp mat4 skinMatrix() {\n    return\n      getBoneMatrix(a_joints.x * 2.0 + 1.0) * getBoneMatrix(a_joints.x * 2.0 + 0.0) * a_weights.x +\n      getBoneMatrix(a_joints.y * 2.0 + 1.0) * getBoneMatrix(a_joints.y * 2.0 + 0.0) * a_weights.y +\n      getBoneMatrix(a_joints.z * 2.0 + 1.0) * getBoneMatrix(a_joints.z * 2.0 + 0.0) * a_weights.z +\n      getBoneMatrix(a_joints.w * 2.0 + 1.0) * getBoneMatrix(a_joints.w * 2.0 + 0.0) * a_weights.w;\n  }\n#else\n  highp mat4 skinMatrix() {\n    return\n      getBoneMatrix(a_joints.x) * a_weights.x +\n      getBoneMatrix(a_joints.y) * a_weights.y +\n      getBoneMatrix(a_joints.z) * a_weights.z +\n      getBoneMatrix(a_joints.w) * a_weights.w;\n  }\n#endif\n#else\nmat4 getBoneMatrix(const in float i) {\n  vec4 _0 = cc_matJoint[3 * int(i) + 0];\n  vec4 _1 = cc_matJoint[3 * int(i) + 1];\n  vec4 _2 = cc_matJoint[3 * int(i) + 2];\n  return mat4(\n      vec4(_0.x, _0.y, _0.z, 0),\n      vec4(_0.w, _1.x, _1.y, 0),\n      vec4(_1.z, _1.w, _2.x, 0),\n      vec4(_2.y, _2.z, _2.w, 1)\n  );\n}\nmat4 skinMatrix() {\n  return\n    getBoneMatrix(a_joints.x) * a_weights.x +\n    getBoneMatrix(a_joints.y) * a_weights.y +\n    getBoneMatrix(a_joints.z) * a_weights.z +\n    getBoneMatrix(a_joints.w) * a_weights.w;\n}\n#endif\nvoid skinVertex(inout highp vec4 a1) {\n  highp mat4 m = skinMatrix();\n  a1 = m * a1;\n}\nvoid skinVertex(inout highp vec4 a1, inout vec4 a2) {\n  highp mat4 m = skinMatrix();\n  a1 = m * a1;\n  a2 = m * a2;\n}\nvoid skinVertex(inout highp vec4 a1, inout vec4 a2, inout vec4 a3) {\n  highp mat4 m = skinMatrix();\n  a1 = m * a1;\n  a2 = m * a2;\n  a3 = m * a3;\n}\n  #endif\n  attribute vec3 a_position;\n  vec4 vert () {\n#if CC_USE_SKINNING\n    highp\n#endif\n    vec4 pos = vec4(a_position, 1);\n    #if CC_USE_SKINNING\n      skinVertex(pos);\n    #else\n      pos = cc_matWorld * pos;\n    #endif\n    pos = cc_matViewProj * cc_matLightPlaneProj * pos;\n    pos.z -= 0.0001;\n    return pos;\n  }\nvoid main() { gl_Position = vert(); }\n`,
          "frag": `\nprecision mediump float;\nuniform mat4 cc_matLightPlaneProj;\nuniform vec4 cc_shadowColor;\nuniform vec4 cc_time;\nuniform vec4 cc_screenSize;\nuniform vec4 cc_screenScale;\nuniform vec4 cc_nativeSize;\nuniform mat4 cc_matView;\nuniform mat4 cc_matViewInv;\nuniform mat4 cc_matProj;\nuniform mat4 cc_matProjInv;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matViewProjInv;\nuniform vec4 cc_cameraPos;\nuniform vec4 cc_exposure;\nuniform vec4 cc_mainLitDir;\nuniform vec4 cc_mainLitColor;\nuniform vec4 cc_ambientSky;\nuniform vec4 cc_ambientGround;\nvec4 PostProcess(vec4 color)\n{\n#if CC_USE_HDR\n	color.rgb = mix(color.rgb, pow(color.rgb, vec3(2.2)) * cc_exposure.w, vec3(cc_exposure.z));\n#endif\n	return color;\n}\nvec4 frag () {\n  return PostProcess(cc_shadowColor);\n}\nvoid main() { gl_FragColor = frag(); }\n`
        },
        "builtins": {"globals":{"blocks":["CCGlobal", "CCShadow"], "samplers":[]}, "locals":{"blocks":["CCLocal", "CCSkinningTextureCase", "CCSkinning"], "samplers":["cc_jointsTexture"]}},
        "defines": [
          {"name":"CC_USE_SKINNING", "type":"boolean", "defines":[]},
          {"name":"CC_USE_JOINTS_TEXTURE", "type":"boolean", "defines":["CC_USE_SKINNING"]},
          {"name":"CC_USE_JOINTS_TEXTURE_RGBA8888", "type":"boolean", "defines":["CC_USE_SKINNING", "CC_USE_JOINTS_TEXTURE"]},
          {"name":"CC_BINDPOSE_COMPUTATION_DEFERED", "type":"boolean", "defines":["CC_USE_SKINNING", "CC_USE_JOINTS_TEXTURE"]},
          {"name":"CC_USE_HDR", "type":"boolean", "defines":[]}
        ],
        "blocks": [],
        "samplers": [],
        "dependencies": {}
      }
    ]
  },
  {
    "name": "builtin-unlit",
    "techniques": [
      {"name":"opaque", "passes":[{"program":"builtin-unlit|unlit-vs:vert|unlit-fs:frag", "properties":{"color":{"value":[1, 1, 1, 1], "inspector":{"type":"color"}, "type":16}, "tilingOffset":{"value":[1, 1, 0, 0], "type":16}, "mainTexture":{"value":"grey", "type":28}}}]}
    ],
    "shaders": [
      {
        "name": "builtin-unlit|unlit-vs:vert|unlit-fs:frag",
        "hash": 3765254617,
        "glsl3": {
          "vert": `\n  precision mediump float;\nuniform CCGlobal {\n  vec4 cc_time; \n  vec4 cc_screenSize; \n  vec4 cc_screenScale; \n  vec4 cc_nativeSize; \n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos; \n  vec4 cc_exposure; \n  vec4 cc_mainLitDir; \n  vec4 cc_mainLitColor; \n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\n  #if CC_USE_SKINNING\nin vec4 a_weights;\nin vec4 a_joints;\n#if CC_USE_JOINTS_TEXTURE\n  \n  uniform CCSkinningTextureCase {\n    vec4 cc_jointsTextureSize;\n  };\n#else\n  \n  uniform CCSkinning {\n    vec4 cc_matJoint[65 * 3];\n  };\n#endif\n#if CC_USE_JOINTS_TEXTURE\nuniform sampler2D cc_jointsTexture;\n#if CC_USE_JOINTS_TEXTURE_RGBA8888\nhighp float decode32(highp vec4 rgba) {\n    highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;\n    highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;\n    if (Exponent == -127.0) {\n        return 0.0;\n    }\n    highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);\n    return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nhighp vec4 decodevec4 (highp vec4 x, highp vec4 y, highp vec4 z, highp vec4 w) {\n    return vec4(\n        decode32(x * 255.0),\n        decode32(y * 255.0),\n        decode32(z * 255.0),\n        decode32(w * 255.0)\n    );\n}\nhighp mat4 getBoneMatrix(const in float i) {\n  float size = cc_jointsTextureSize.x;\n  float j = i * 16.0;\n  float x = mod(j, size);\n  float y = floor(j / size);\n  float dx = 1.0 / size;\n  float dy = 1.0 / size;\n  y = dy * (y + 0.5);\n  highp vec4 v1 = decodevec4(\n      texture(cc_jointsTexture, vec2(dx * (x + 0.5), y)),\n      texture(cc_jointsTexture, vec2(dx * (x + 1.5), y)),\n      texture(cc_jointsTexture, vec2(dx * (x + 2.5), y)),\n      texture(cc_jointsTexture, vec2(dx * (x + 3.5), y))\n  );\n  highp vec4 v2 = decodevec4(\n      texture(cc_jointsTexture, vec2(dx * (x + 4.5), y)),\n      texture(cc_jointsTexture, vec2(dx * (x + 5.5), y)),\n      texture(cc_jointsTexture, vec2(dx * (x + 6.5), y)),\n      texture(cc_jointsTexture, vec2(dx * (x + 7.5), y))\n  );\n  highp vec4 v3 = decodevec4(\n      texture(cc_jointsTexture, vec2(dx * (x + 8.5), y)),\n      texture(cc_jointsTexture, vec2(dx * (x + 9.5), y)),\n      texture(cc_jointsTexture, vec2(dx * (x + 10.5), y)),\n      texture(cc_jointsTexture, vec2(dx * (x + 11.5), y))\n  );\n  highp vec4 v4 = decodevec4(\n      texture(cc_jointsTexture, vec2(dx * (x + 12.5), y)),\n      texture(cc_jointsTexture, vec2(dx * (x + 13.5), y)),\n      texture(cc_jointsTexture, vec2(dx * (x + 14.5), y)),\n      texture(cc_jointsTexture, vec2(dx * (x + 15.5), y))\n  );\n  return mat4(v1, v2, v3, v4);\n}\n#else\nmat4 getBoneMatrix(const in float i) {\n  float size = cc_jointsTextureSize.x;\n  float j = i * 4.0;\n  float x = mod(j, size);\n  float y = floor(j / size);\n  float dx = 1.0 / size;\n  float dy = 1.0 / size;\n  y = dy * (y + 0.5);\n  vec4 v1 = texture(cc_jointsTexture, vec2(dx * (x + 0.5), y));\n  vec4 v2 = texture(cc_jointsTexture, vec2(dx * (x + 1.5), y));\n  vec4 v3 = texture(cc_jointsTexture, vec2(dx * (x + 2.5), y));\n  vec4 v4 = texture(cc_jointsTexture, vec2(dx * (x + 3.5), y));\n  return mat4(v1, v2, v3, v4);\n}\n#endif\n#if CC_BINDPOSE_COMPUTATION_DEFERED\n  highp mat4 skinMatrix() {\n    return\n      getBoneMatrix(a_joints.x * 2.0 + 1.0) * getBoneMatrix(a_joints.x * 2.0 + 0.0) * a_weights.x +\n      getBoneMatrix(a_joints.y * 2.0 + 1.0) * getBoneMatrix(a_joints.y * 2.0 + 0.0) * a_weights.y +\n      getBoneMatrix(a_joints.z * 2.0 + 1.0) * getBoneMatrix(a_joints.z * 2.0 + 0.0) * a_weights.z +\n      getBoneMatrix(a_joints.w * 2.0 + 1.0) * getBoneMatrix(a_joints.w * 2.0 + 0.0) * a_weights.w;\n  }\n#else\n  highp mat4 skinMatrix() {\n    return\n      getBoneMatrix(a_joints.x) * a_weights.x +\n      getBoneMatrix(a_joints.y) * a_weights.y +\n      getBoneMatrix(a_joints.z) * a_weights.z +\n      getBoneMatrix(a_joints.w) * a_weights.w;\n  }\n#endif\n#else\nmat4 getBoneMatrix(const in float i) {\n  vec4 _0 = cc_matJoint[3 * int(i) + 0];\n  vec4 _1 = cc_matJoint[3 * int(i) + 1];\n  vec4 _2 = cc_matJoint[3 * int(i) + 2];\n  return mat4(\n      vec4(_0.x, _0.y, _0.z, 0),\n      vec4(_0.w, _1.x, _1.y, 0),\n      vec4(_1.z, _1.w, _2.x, 0),\n      vec4(_2.y, _2.z, _2.w, 1)\n  );\n}\nmat4 skinMatrix() {\n  return\n    getBoneMatrix(a_joints.x) * a_weights.x +\n    getBoneMatrix(a_joints.y) * a_weights.y +\n    getBoneMatrix(a_joints.z) * a_weights.z +\n    getBoneMatrix(a_joints.w) * a_weights.w;\n}\n#endif\nvoid skinVertex(inout highp vec4 a1) {\n  highp mat4 m = skinMatrix();\n  a1 = m * a1;\n}\nvoid skinVertex(inout highp vec4 a1, inout vec4 a2) {\n  highp mat4 m = skinMatrix();\n  a1 = m * a1;\n  a2 = m * a2;\n}\nvoid skinVertex(inout highp vec4 a1, inout vec4 a2, inout vec4 a3) {\n  highp mat4 m = skinMatrix();\n  a1 = m * a1;\n  a2 = m * a2;\n  a3 = m * a3;\n}\n  #endif\n  in vec3 a_position;\n  #if USE_TEXTURE\n    in vec2 a_texCoord;\n    out vec2 uv0;\n    uniform TexCoords {\n      vec4 tilingOffset;\n    };\n  #endif\n  vec4 vert () {\n#if CC_USE_SKINNING\n    highp\n#endif\n    vec4 pos = vec4(a_position, 1);\n    #if CC_USE_SKINNING\n      skinVertex(pos);\n    #else\n      pos = cc_matWorld * pos;\n    #endif\n    pos = cc_matViewProj * pos;\n    #if USE_TEXTURE\n      uv0 = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n    #endif\n    return pos;\n  }\nvoid main() { gl_Position = vert(); }\n`,
          "frag": `\nprecision mediump float;\nuniform CCGlobal {\n  vec4 cc_time; \n  vec4 cc_screenSize; \n  vec4 cc_screenScale; \n  vec4 cc_nativeSize; \n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos; \n  vec4 cc_exposure; \n  vec4 cc_mainLitDir; \n  vec4 cc_mainLitColor; \n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nvec4 PostProcess(vec4 color)\n{\n#if CC_USE_HDR\n	color.rgb = mix(color.rgb, pow(color.rgb, vec3(2.2)) * cc_exposure.w, vec3(cc_exposure.z));\n#endif\n	return color;\n}\n#if USE_TEXTURE\n  in vec2 uv0;\n  uniform sampler2D mainTexture;\n#endif\n#if USE_COLOR\n  uniform Constant {\n    vec4 color;\n  };\n#endif\nvec4 frag () {\n  vec4 o = vec4(1, 1, 1, 1);\n  #if USE_TEXTURE\n    o *= texture(mainTexture, uv0);\n  #endif\n  #if USE_COLOR\n    o *= color;\n  #endif\n  return PostProcess(o);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }\n`
        },
        "glsl1": {
          "vert": `\n  precision mediump float;\nuniform vec4 cc_time;\nuniform vec4 cc_screenSize;\nuniform vec4 cc_screenScale;\nuniform vec4 cc_nativeSize;\nuniform mat4 cc_matView;\nuniform mat4 cc_matViewInv;\nuniform mat4 cc_matProj;\nuniform mat4 cc_matProjInv;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matViewProjInv;\nuniform vec4 cc_cameraPos;\nuniform vec4 cc_exposure;\nuniform vec4 cc_mainLitDir;\nuniform vec4 cc_mainLitColor;\nuniform vec4 cc_ambientSky;\nuniform vec4 cc_ambientGround;\nuniform mat4 cc_matWorld;\nuniform mat4 cc_matWorldIT;\n  #if CC_USE_SKINNING\nattribute vec4 a_weights;\nattribute vec4 a_joints;\n#if CC_USE_JOINTS_TEXTURE\n  \n  uniform vec4 cc_jointsTextureSize;\n#else\n  \n  uniform vec4 cc_matJoint[195];\n#endif\n#if CC_USE_JOINTS_TEXTURE\nuniform sampler2D cc_jointsTexture;\n#if CC_USE_JOINTS_TEXTURE_RGBA8888\nhighp float decode32(highp vec4 rgba) {\n    highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;\n    highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;\n    if (Exponent == -127.0) {\n        return 0.0;\n    }\n    highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);\n    return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nhighp vec4 decodevec4 (highp vec4 x, highp vec4 y, highp vec4 z, highp vec4 w) {\n    return vec4(\n        decode32(x * 255.0),\n        decode32(y * 255.0),\n        decode32(z * 255.0),\n        decode32(w * 255.0)\n    );\n}\nhighp mat4 getBoneMatrix(const in float i) {\n  float size = cc_jointsTextureSize.x;\n  float j = i * 16.0;\n  float x = mod(j, size);\n  float y = floor(j / size);\n  float dx = 1.0 / size;\n  float dy = 1.0 / size;\n  y = dy * (y + 0.5);\n  highp vec4 v1 = decodevec4(\n      texture2D(cc_jointsTexture, vec2(dx * (x + 0.5), y)),\n      texture2D(cc_jointsTexture, vec2(dx * (x + 1.5), y)),\n      texture2D(cc_jointsTexture, vec2(dx * (x + 2.5), y)),\n      texture2D(cc_jointsTexture, vec2(dx * (x + 3.5), y))\n  );\n  highp vec4 v2 = decodevec4(\n      texture2D(cc_jointsTexture, vec2(dx * (x + 4.5), y)),\n      texture2D(cc_jointsTexture, vec2(dx * (x + 5.5), y)),\n      texture2D(cc_jointsTexture, vec2(dx * (x + 6.5), y)),\n      texture2D(cc_jointsTexture, vec2(dx * (x + 7.5), y))\n  );\n  highp vec4 v3 = decodevec4(\n      texture2D(cc_jointsTexture, vec2(dx * (x + 8.5), y)),\n      texture2D(cc_jointsTexture, vec2(dx * (x + 9.5), y)),\n      texture2D(cc_jointsTexture, vec2(dx * (x + 10.5), y)),\n      texture2D(cc_jointsTexture, vec2(dx * (x + 11.5), y))\n  );\n  highp vec4 v4 = decodevec4(\n      texture2D(cc_jointsTexture, vec2(dx * (x + 12.5), y)),\n      texture2D(cc_jointsTexture, vec2(dx * (x + 13.5), y)),\n      texture2D(cc_jointsTexture, vec2(dx * (x + 14.5), y)),\n      texture2D(cc_jointsTexture, vec2(dx * (x + 15.5), y))\n  );\n  return mat4(v1, v2, v3, v4);\n}\n#else\nmat4 getBoneMatrix(const in float i) {\n  float size = cc_jointsTextureSize.x;\n  float j = i * 4.0;\n  float x = mod(j, size);\n  float y = floor(j / size);\n  float dx = 1.0 / size;\n  float dy = 1.0 / size;\n  y = dy * (y + 0.5);\n  vec4 v1 = texture2D(cc_jointsTexture, vec2(dx * (x + 0.5), y));\n  vec4 v2 = texture2D(cc_jointsTexture, vec2(dx * (x + 1.5), y));\n  vec4 v3 = texture2D(cc_jointsTexture, vec2(dx * (x + 2.5), y));\n  vec4 v4 = texture2D(cc_jointsTexture, vec2(dx * (x + 3.5), y));\n  return mat4(v1, v2, v3, v4);\n}\n#endif\n#if CC_BINDPOSE_COMPUTATION_DEFERED\n  highp mat4 skinMatrix() {\n    return\n      getBoneMatrix(a_joints.x * 2.0 + 1.0) * getBoneMatrix(a_joints.x * 2.0 + 0.0) * a_weights.x +\n      getBoneMatrix(a_joints.y * 2.0 + 1.0) * getBoneMatrix(a_joints.y * 2.0 + 0.0) * a_weights.y +\n      getBoneMatrix(a_joints.z * 2.0 + 1.0) * getBoneMatrix(a_joints.z * 2.0 + 0.0) * a_weights.z +\n      getBoneMatrix(a_joints.w * 2.0 + 1.0) * getBoneMatrix(a_joints.w * 2.0 + 0.0) * a_weights.w;\n  }\n#else\n  highp mat4 skinMatrix() {\n    return\n      getBoneMatrix(a_joints.x) * a_weights.x +\n      getBoneMatrix(a_joints.y) * a_weights.y +\n      getBoneMatrix(a_joints.z) * a_weights.z +\n      getBoneMatrix(a_joints.w) * a_weights.w;\n  }\n#endif\n#else\nmat4 getBoneMatrix(const in float i) {\n  vec4 _0 = cc_matJoint[3 * int(i) + 0];\n  vec4 _1 = cc_matJoint[3 * int(i) + 1];\n  vec4 _2 = cc_matJoint[3 * int(i) + 2];\n  return mat4(\n      vec4(_0.x, _0.y, _0.z, 0),\n      vec4(_0.w, _1.x, _1.y, 0),\n      vec4(_1.z, _1.w, _2.x, 0),\n      vec4(_2.y, _2.z, _2.w, 1)\n  );\n}\nmat4 skinMatrix() {\n  return\n    getBoneMatrix(a_joints.x) * a_weights.x +\n    getBoneMatrix(a_joints.y) * a_weights.y +\n    getBoneMatrix(a_joints.z) * a_weights.z +\n    getBoneMatrix(a_joints.w) * a_weights.w;\n}\n#endif\nvoid skinVertex(inout highp vec4 a1) {\n  highp mat4 m = skinMatrix();\n  a1 = m * a1;\n}\nvoid skinVertex(inout highp vec4 a1, inout vec4 a2) {\n  highp mat4 m = skinMatrix();\n  a1 = m * a1;\n  a2 = m * a2;\n}\nvoid skinVertex(inout highp vec4 a1, inout vec4 a2, inout vec4 a3) {\n  highp mat4 m = skinMatrix();\n  a1 = m * a1;\n  a2 = m * a2;\n  a3 = m * a3;\n}\n  #endif\n  attribute vec3 a_position;\n  #if USE_TEXTURE\n    attribute vec2 a_texCoord;\n    varying vec2 uv0;\n    uniform vec4 tilingOffset;\n  #endif\n  vec4 vert () {\n#if CC_USE_SKINNING\n    highp\n#endif\n    vec4 pos = vec4(a_position, 1);\n    #if CC_USE_SKINNING\n      skinVertex(pos);\n    #else\n      pos = cc_matWorld * pos;\n    #endif\n    pos = cc_matViewProj * pos;\n    #if USE_TEXTURE\n      uv0 = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n    #endif\n    return pos;\n  }\nvoid main() { gl_Position = vert(); }\n`,
          "frag": `\nprecision mediump float;\nuniform vec4 cc_time;\nuniform vec4 cc_screenSize;\nuniform vec4 cc_screenScale;\nuniform vec4 cc_nativeSize;\nuniform mat4 cc_matView;\nuniform mat4 cc_matViewInv;\nuniform mat4 cc_matProj;\nuniform mat4 cc_matProjInv;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matViewProjInv;\nuniform vec4 cc_cameraPos;\nuniform vec4 cc_exposure;\nuniform vec4 cc_mainLitDir;\nuniform vec4 cc_mainLitColor;\nuniform vec4 cc_ambientSky;\nuniform vec4 cc_ambientGround;\nvec4 PostProcess(vec4 color)\n{\n#if CC_USE_HDR\n	color.rgb = mix(color.rgb, pow(color.rgb, vec3(2.2)) * cc_exposure.w, vec3(cc_exposure.z));\n#endif\n	return color;\n}\n#if USE_TEXTURE\n  varying vec2 uv0;\n  uniform sampler2D mainTexture;\n#endif\n#if USE_COLOR\n  uniform vec4 color;\n#endif\nvec4 frag () {\n  vec4 o = vec4(1, 1, 1, 1);\n  #if USE_TEXTURE\n    o *= texture2D(mainTexture, uv0);\n  #endif\n  #if USE_COLOR\n    o *= color;\n  #endif\n  return PostProcess(o);\n}\nvoid main() { gl_FragColor = frag(); }\n`
        },
        "builtins": {"globals":{"blocks":["CCGlobal"], "samplers":[]}, "locals":{"blocks":["CCLocal", "CCSkinningTextureCase", "CCSkinning"], "samplers":["cc_jointsTexture"]}},
        "defines": [
          {"name":"CC_USE_SKINNING", "type":"boolean", "defines":[]},
          {"name":"CC_USE_JOINTS_TEXTURE", "type":"boolean", "defines":["CC_USE_SKINNING"]},
          {"name":"CC_USE_JOINTS_TEXTURE_RGBA8888", "type":"boolean", "defines":["CC_USE_SKINNING", "CC_USE_JOINTS_TEXTURE"]},
          {"name":"CC_BINDPOSE_COMPUTATION_DEFERED", "type":"boolean", "defines":["CC_USE_SKINNING", "CC_USE_JOINTS_TEXTURE"]},
          {"name":"USE_TEXTURE", "type":"boolean", "defines":[]},
          {"name":"CC_USE_HDR", "type":"boolean", "defines":[]},
          {"name":"USE_COLOR", "type":"boolean", "defines":[]}
        ],
        "blocks": [
          {"name": "TexCoords", "size": 16, "defines": ["USE_TEXTURE"], "binding": 0, "members": [
            {"name":"tilingOffset", "type":16, "count":1, "size":16}
          ]},
          {"name": "Constant", "size": 16, "defines": ["USE_COLOR"], "binding": 1, "members": [
            {"name":"color", "type":16, "count":1, "size":16}
          ]}
        ],
        "samplers": [
          {"name":"mainTexture", "type":28, "count":1, "defines":["USE_TEXTURE"], "binding":2}
        ],
        "dependencies": {}
      }
    ]
  },
  {
    "name": "pipeline/smaa",
    "techniques": [
      {"name":"smaa", "passes":[{"program":"pipeline/smaa|smaa-edge-vs:vert|smaa-edge-fs:frag", "depthStencilState":{"depthTest":false, "depthWrite":false}, "properties":{"u_texSampler":{"sampler":[2, 2, null, 2, 2], "type":28}}}, {"program":"pipeline/smaa|smaa-blend-vs:vert|smaa-blend-fs:frag", "depthStencilState":{"depthTest":false, "depthWrite":false}, "properties":{"u_edgeTexSampler":{"sampler":[2, 2, null, 2, 2], "type":28}, "u_areaTexSampler":{"sampler":[2, 2, null, 2, 2], "type":28}, "u_searchTexSampler":{"sampler":[1, 1, null, 2, 2], "type":28}}}]}
    ],
    "shaders": [
      {
        "name": "pipeline/smaa|smaa-edge-vs:vert|smaa-edge-fs:frag",
        "hash": 227200819,
        "glsl3": {
          "vert": `\nprecision highp float;\nuniform CCGlobal {\n  vec4 cc_time; \n  vec4 cc_screenSize; \n  vec4 cc_screenScale; \n  vec4 cc_nativeSize; \n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos; \n  vec4 cc_exposure; \n  vec4 cc_mainLitDir; \n  vec4 cc_mainLitColor; \n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nin vec2 a_position;\nin vec2 a_texCoord;\nout vec2 v_uv;\nout vec4 v_offsets[3];\nvec4 vert () {\n  vec4 pos = vec4(a_position, 0.0, 1.0);\n  v_uv = a_texCoord * cc_screenScale.xy;\n  v_offsets[0] = v_uv.xyxy + cc_nativeSize.zwzw * vec4(-1.0, 0.0, 0.0, 1.0);\n  v_offsets[1] = v_uv.xyxy + cc_nativeSize.zwzw * vec4( 1.0, 0.0, 0.0, -1.0);\n  v_offsets[2] = v_uv.xyxy + cc_nativeSize.zwzw * vec4(-2.0, 0.0, 0.0, 2.0);\n  return pos;\n}\nvoid main() { gl_Position = vert(); }\n`,
          "frag": `\nprecision highp float;\nuniform CCGlobal {\n  vec4 cc_time; \n  vec4 cc_screenSize; \n  vec4 cc_screenScale; \n  vec4 cc_nativeSize; \n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos; \n  vec4 cc_exposure; \n  vec4 cc_mainLitDir; \n  vec4 cc_mainLitColor; \n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\n#define PI 3.14159265359\n#define PI2 6.28318530718\n#define EPSILON 1e-6\n#define LOG2 1.442695\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define FP_MAX          65504.0\n#define FP_SCALE        0.0009765625\n#define FP_SCALE_INV    1024.0\nvec3 SRGBToLinear(vec3 gamma)\n{\n	return pow(gamma, vec3(2.2));\n	\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n	return pow(linear, vec3(0.454545));\n	\n}\nvec3 ACESToneMap(vec3 color) {\n    const float A = 2.51;\n    const float B = 0.03;\n    const float C = 2.43;\n    const float D = 0.59;\n    const float E = 0.14;\n    return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\n#define SMAA_THRESHOLD 0.1\nin vec2 v_uv;\nin vec4 v_offsets[3];\nuniform sampler2D u_texSampler;\nvec3 ToLDR(vec3 color) {\n#if CC_USE_HDR\n  color *= cc_exposure.x * 1024.0;\n  color = ACESToneMap(color);\n  color = LinearToSRGB(color);\n#endif\n  return color;\n}\nvec4 frag () {\n  vec2 threshold = vec2(0.1, 0.1);\n  vec4 delta;\n  vec3 C = ToLDR(texture(u_texSampler, v_uv).rgb);\n  vec3 Cleft = ToLDR(texture(u_texSampler, v_offsets[0].xy).rgb);\n  vec3 t = abs(C - Cleft);\n  delta.x = max(max(t.r, t.g), t.b);\n  vec3 Ctop = ToLDR(texture(u_texSampler, v_offsets[0].zw).rgb);\n  t = abs(C - Ctop);\n  delta.y = max(max(t.r, t.g), t.b);\n  vec2 edges = step(threshold, delta.xy);\n  if (dot(edges, vec2(1.0, 1.0)) == 0.0)\n    discard;\n  vec3 Cright = ToLDR(texture(u_texSampler, v_offsets[1].xy).rgb);\n  t = abs(C - Cright);\n  delta.z = max(max(t.r, t.g), t.b);\n  vec3 Cbottom = ToLDR(texture(u_texSampler, v_offsets[1].zw).rgb);\n  t = abs(C - Cbottom);\n  delta.w = max(max(t.r, t.g), t.b);\n  float maxDelta = max(max(max(delta.x, delta.y), delta.z), delta.w);\n  vec3 Cleftleft = ToLDR(texture(u_texSampler, v_offsets[2].xy).rgb);\n  t = abs(C - Cleftleft);\n  delta.z = max(max(t.r, t.g), t.b);\n  vec3 Ctoptop = ToLDR(texture(u_texSampler, v_offsets[2].zw).rgb);\n  t = abs(C - Ctoptop);\n  delta.w = max(max(t.r, t.g), t.b);\n  maxDelta = max(max(maxDelta, delta.z), delta.w);\n  edges.xy *= step(0.5 * maxDelta, delta.xy);\n  vec4 o = vec4(edges, 0.0, 0.0);\n  return o;\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }\n`
        },
        "glsl1": {
          "vert": `\nprecision highp float;\nuniform vec4 cc_time;\nuniform vec4 cc_screenSize;\nuniform vec4 cc_screenScale;\nuniform vec4 cc_nativeSize;\nuniform mat4 cc_matView;\nuniform mat4 cc_matViewInv;\nuniform mat4 cc_matProj;\nuniform mat4 cc_matProjInv;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matViewProjInv;\nuniform vec4 cc_cameraPos;\nuniform vec4 cc_exposure;\nuniform vec4 cc_mainLitDir;\nuniform vec4 cc_mainLitColor;\nuniform vec4 cc_ambientSky;\nuniform vec4 cc_ambientGround;\nattribute vec2 a_position;\nattribute vec2 a_texCoord;\nvarying vec2 v_uv;\nvarying vec4 v_offsets[3];\nvec4 vert () {\n  vec4 pos = vec4(a_position, 0.0, 1.0);\n  v_uv = a_texCoord * cc_screenScale.xy;\n  v_offsets[0] = v_uv.xyxy + cc_nativeSize.zwzw * vec4(-1.0, 0.0, 0.0, 1.0);\n  v_offsets[1] = v_uv.xyxy + cc_nativeSize.zwzw * vec4( 1.0, 0.0, 0.0, -1.0);\n  v_offsets[2] = v_uv.xyxy + cc_nativeSize.zwzw * vec4(-2.0, 0.0, 0.0, 2.0);\n  return pos;\n}\nvoid main() { gl_Position = vert(); }\n`,
          "frag": `\nprecision highp float;\nuniform vec4 cc_time;\nuniform vec4 cc_screenSize;\nuniform vec4 cc_screenScale;\nuniform vec4 cc_nativeSize;\nuniform mat4 cc_matView;\nuniform mat4 cc_matViewInv;\nuniform mat4 cc_matProj;\nuniform mat4 cc_matProjInv;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matViewProjInv;\nuniform vec4 cc_cameraPos;\nuniform vec4 cc_exposure;\nuniform vec4 cc_mainLitDir;\nuniform vec4 cc_mainLitColor;\nuniform vec4 cc_ambientSky;\nuniform vec4 cc_ambientGround;\n#define PI 3.14159265359\n#define PI2 6.28318530718\n#define EPSILON 1e-6\n#define LOG2 1.442695\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define FP_MAX          65504.0\n#define FP_SCALE        0.0009765625\n#define FP_SCALE_INV    1024.0\nvec3 SRGBToLinear(vec3 gamma)\n{\n	return pow(gamma, vec3(2.2));\n	\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n	return pow(linear, vec3(0.454545));\n	\n}\nvec3 ACESToneMap(vec3 color) {\n    const float A = 2.51;\n    const float B = 0.03;\n    const float C = 2.43;\n    const float D = 0.59;\n    const float E = 0.14;\n    return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\n#define SMAA_THRESHOLD 0.1\nvarying vec2 v_uv;\nvarying vec4 v_offsets[3];\nuniform sampler2D u_texSampler;\nvec3 ToLDR(vec3 color) {\n#if CC_USE_HDR\n  color *= cc_exposure.x * 1024.0;\n  color = ACESToneMap(color);\n  color = LinearToSRGB(color);\n#endif\n  return color;\n}\nvec4 frag () {\n  vec2 threshold = vec2(0.1, 0.1);\n  vec4 delta;\n  vec3 C = ToLDR(texture2D(u_texSampler, v_uv).rgb);\n  vec3 Cleft = ToLDR(texture2D(u_texSampler, v_offsets[0].xy).rgb);\n  vec3 t = abs(C - Cleft);\n  delta.x = max(max(t.r, t.g), t.b);\n  vec3 Ctop = ToLDR(texture2D(u_texSampler, v_offsets[0].zw).rgb);\n  t = abs(C - Ctop);\n  delta.y = max(max(t.r, t.g), t.b);\n  vec2 edges = step(threshold, delta.xy);\n  if (dot(edges, vec2(1.0, 1.0)) == 0.0)\n    discard;\n  vec3 Cright = ToLDR(texture2D(u_texSampler, v_offsets[1].xy).rgb);\n  t = abs(C - Cright);\n  delta.z = max(max(t.r, t.g), t.b);\n  vec3 Cbottom = ToLDR(texture2D(u_texSampler, v_offsets[1].zw).rgb);\n  t = abs(C - Cbottom);\n  delta.w = max(max(t.r, t.g), t.b);\n  float maxDelta = max(max(max(delta.x, delta.y), delta.z), delta.w);\n  vec3 Cleftleft = ToLDR(texture2D(u_texSampler, v_offsets[2].xy).rgb);\n  t = abs(C - Cleftleft);\n  delta.z = max(max(t.r, t.g), t.b);\n  vec3 Ctoptop = ToLDR(texture2D(u_texSampler, v_offsets[2].zw).rgb);\n  t = abs(C - Ctoptop);\n  delta.w = max(max(t.r, t.g), t.b);\n  maxDelta = max(max(maxDelta, delta.z), delta.w);\n  edges.xy *= step(0.5 * maxDelta, delta.xy);\n  vec4 o = vec4(edges, 0.0, 0.0);\n  return o;\n}\nvoid main() { gl_FragColor = frag(); }\n`
        },
        "builtins": {"globals":{"blocks":["CCGlobal"], "samplers":[]}, "locals":{"blocks":[], "samplers":[]}},
        "defines": [
          {"name":"CC_USE_HDR", "type":"boolean", "defines":[]}
        ],
        "blocks": [],
        "samplers": [
          {"name":"u_texSampler", "type":28, "count":1, "defines":[], "binding":0}
        ],
        "dependencies": {}
      },
      {
        "name": "pipeline/smaa|smaa-blend-vs:vert|smaa-blend-fs:frag",
        "hash": 3930519611,
        "glsl3": {
          "vert": `\nprecision highp float;\nuniform CCGlobal {\n  vec4 cc_time; \n  vec4 cc_screenSize; \n  vec4 cc_screenScale; \n  vec4 cc_nativeSize; \n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos; \n  vec4 cc_exposure; \n  vec4 cc_mainLitDir; \n  vec4 cc_mainLitColor; \n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\n#define SMAA_MAX_SEARCH_STEPS 8\nin vec2 a_position;\nin vec2 a_texCoord;\nout vec2 v_uv;\nout vec4 v_offsets[3];\nout vec2 v_pixCoord;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 0.0, 1.0);\n  v_uv = a_texCoord * cc_screenScale.xy;\n  v_pixCoord = v_uv * cc_nativeSize.xy;\n  v_offsets[0] = v_uv.xyxy + cc_nativeSize.zwzw * vec4(-0.25, 0.125, 1.25, 0.125);\n  v_offsets[1] = v_uv.xyxy + cc_nativeSize.zwzw * vec4(-0.125, 0.25, -0.125, -1.25);\n  v_offsets[2] = vec4(v_offsets[0].xz, v_offsets[1].yw) + vec4(-2.0, 2.0, -2.0, 2.0) * cc_nativeSize.zzww * float(8);\n  return pos;\n}\nvoid main() { gl_Position = vert(); }\n`,
          "frag": `\nprecision highp float;\nuniform CCGlobal {\n  vec4 cc_time; \n  vec4 cc_screenSize; \n  vec4 cc_screenScale; \n  vec4 cc_nativeSize; \n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos; \n  vec4 cc_exposure; \n  vec4 cc_mainLitDir; \n  vec4 cc_mainLitColor; \n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\n#define SMAA_MAX_SEARCH_STEPS 8\n#define SMAA_AREATEX_MAX_DISTANCE 16\n#define SMAA_AREATEX_PIXEL_SIZE (1.0 / vec2(160.0, 560.0))\n#define SMAA_AREATEX_SUBTEX_SIZE (1.0 / 7.0)\nin vec2 v_uv;\nin vec4 v_offsets[3];\nin vec2 v_pixCoord;\nuniform sampler2D u_edgeTexSampler;\nuniform sampler2D u_areaTexSampler;\nuniform sampler2D u_searchTexSampler;\nfloat SMAASearchLength(vec2 e, float bias, float scale) {\n  e.r = bias + e.r * scale;\n  return 255.0 * texture(u_searchTexSampler, e).r;\n}\nfloat SMAASearchXLeft(vec2 texcoord, float end) {\n  vec2 e = vec2(0.0, 1.0);\n  for (int i = 0; i < 8; ++i) {\n      e = texture(u_edgeTexSampler, texcoord).rg;\n      texcoord -= vec2( 2.0, 0.0 ) * cc_nativeSize.zw;\n      if (!(texcoord.x > end && e.g > 0.8281 && e.r == 0.0))\n        break;\n  }\n  texcoord.x += 0.25 * cc_nativeSize.z;\n  texcoord.x += cc_nativeSize.z;\n  texcoord.x += 2.0 * cc_nativeSize.z;\n  texcoord.x -= cc_nativeSize.z * SMAASearchLength(e, 0.0, 0.5);\n  return texcoord.x;\n}\nfloat SMAASearchXRight(vec2 texcoord, float end) {\n  vec2 e = vec2(0.0, 1.0);\n  for (int i = 0; i < 8; ++i) {\n      e = texture(u_edgeTexSampler, texcoord).rg;\n      texcoord += vec2( 2.0, 0.0 ) * cc_nativeSize.zw;\n      if (!(texcoord.x < end && e.g > 0.8281 && e.r == 0.0))\n        break;\n  }\n  texcoord.x -= 0.25 * cc_nativeSize.z;\n  texcoord.x -= cc_nativeSize.z;\n  texcoord.x -= 2.0 * cc_nativeSize.z;\n  texcoord.x += cc_nativeSize.z * SMAASearchLength(e, 0.5, 0.5);\n  return texcoord.x;\n}\nfloat SMAASearchYUp(vec2 texcoord, float end) {\n    vec2 e = vec2(1.0, 0.0);\n    for (int i = 0; i < 8; ++i) {\n        e = texture(u_edgeTexSampler, texcoord).rg;\n        texcoord += vec2( 0.0, 2.0 ) * cc_nativeSize.zw;\n        if (!(texcoord.y > end && e.r > 0.8281 && e.g == 0.0))\n          break;\n    }\n    texcoord.y -= 0.25 * cc_nativeSize.w;\n    texcoord.y -= cc_nativeSize.w;\n    texcoord.y -= 2.0 * cc_nativeSize.w;\n    texcoord.y += cc_nativeSize.w * SMAASearchLength(e.gr, 0.0, 0.5);\n    return texcoord.y;\n}\nfloat SMAASearchYDown(vec2 texcoord, float end) {\n    vec2 e = vec2(1.0, 0.0);\n    for (int i = 0; i < 8; ++i) {\n        e = texture(u_edgeTexSampler, texcoord).rg;\n        texcoord -= vec2( 0.0, 2.0 ) * cc_nativeSize.zw;\n        if (!(texcoord.y < end && e.r > 0.8281 && e.g == 0.0))\n          break;\n    }\n    texcoord.y += 0.25 * cc_nativeSize.w;\n    texcoord.y += cc_nativeSize.w;\n    texcoord.y += 2.0 * cc_nativeSize.w;\n    texcoord.y -= cc_nativeSize.w * SMAASearchLength(e.gr, 0.5, 0.5);\n    return texcoord.y;\n}\nvec2 Round(vec2 x) {\n  return sign(x) * floor(abs(x) + 0.5);\n}\nvec2 SMAAArea(vec2 dist, float e1, float e2) {\n    vec2 texcoord = float(16) * Round(4.0 * vec2(e1, e2)) + dist;\n    texcoord = (1.0 / vec2(160.0, 560.0)) * texcoord + 0.5 * (1.0 / vec2(160.0, 560.0));\n    return texture(u_areaTexSampler, texcoord).rg;\n}\nvec4 frag () {\n  vec4 weights = vec4(0.0);\n  vec2 e = texture(u_edgeTexSampler, v_uv).rg;\n  vec2 d;\n  vec2 coords;\n  if ( e.g > 0.0 ) {\n      coords.x = SMAASearchXLeft(v_offsets[0].xy, v_offsets[2].x);\n      coords.y = v_offsets[1].y;\n      d.x = coords.x;\n      float e1 = texture(u_edgeTexSampler, coords).r;\n      coords.x = SMAASearchXRight(v_offsets[0].zw, v_offsets[2].y);\n      d.y = coords.x;\n      d = d / cc_nativeSize.z - v_pixCoord.x;\n      vec2 sqrt_d = sqrt(abs(d));\n      coords.y -= 1.0 * cc_nativeSize.w;\n      float e2 = texture(u_edgeTexSampler, coords + vec2(cc_nativeSize.z, 0.0)).r;\n      weights.rg = SMAAArea(sqrt_d, e1, e2);\n  }\n  if ( e.r > 0.0 ) {\n      coords.y = SMAASearchYUp(v_offsets[1].xy, v_offsets[2].z);\n      coords.x = v_offsets[0].x;\n      d.x = coords.y;\n      float e1 = texture(u_edgeTexSampler, coords).g;\n      coords.y = SMAASearchYDown(v_offsets[1].zw, v_offsets[2].w);\n      d.y = coords.y;\n      d = d / cc_nativeSize.w - v_pixCoord.y;\n      vec2 sqrt_d = sqrt(abs(d));\n      coords.y -= 1.0 * cc_nativeSize.w;\n      float e2 = texture(u_edgeTexSampler, coords + vec2(0.0, cc_nativeSize.w)).g;\n      weights.ba = SMAAArea(sqrt_d, e1, e2);\n  }\n  return weights;\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }\n`
        },
        "glsl1": {
          "vert": `\nprecision highp float;\nuniform vec4 cc_time;\nuniform vec4 cc_screenSize;\nuniform vec4 cc_screenScale;\nuniform vec4 cc_nativeSize;\nuniform mat4 cc_matView;\nuniform mat4 cc_matViewInv;\nuniform mat4 cc_matProj;\nuniform mat4 cc_matProjInv;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matViewProjInv;\nuniform vec4 cc_cameraPos;\nuniform vec4 cc_exposure;\nuniform vec4 cc_mainLitDir;\nuniform vec4 cc_mainLitColor;\nuniform vec4 cc_ambientSky;\nuniform vec4 cc_ambientGround;\n#define SMAA_MAX_SEARCH_STEPS 8\nattribute vec2 a_position;\nattribute vec2 a_texCoord;\nvarying vec2 v_uv;\nvarying vec4 v_offsets[3];\nvarying vec2 v_pixCoord;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 0.0, 1.0);\n  v_uv = a_texCoord * cc_screenScale.xy;\n  v_pixCoord = v_uv * cc_nativeSize.xy;\n  v_offsets[0] = v_uv.xyxy + cc_nativeSize.zwzw * vec4(-0.25, 0.125, 1.25, 0.125);\n  v_offsets[1] = v_uv.xyxy + cc_nativeSize.zwzw * vec4(-0.125, 0.25, -0.125, -1.25);\n  v_offsets[2] = vec4(v_offsets[0].xz, v_offsets[1].yw) + vec4(-2.0, 2.0, -2.0, 2.0) * cc_nativeSize.zzww * float(8);\n  return pos;\n}\nvoid main() { gl_Position = vert(); }\n`,
          "frag": `\nprecision highp float;\nuniform vec4 cc_time;\nuniform vec4 cc_screenSize;\nuniform vec4 cc_screenScale;\nuniform vec4 cc_nativeSize;\nuniform mat4 cc_matView;\nuniform mat4 cc_matViewInv;\nuniform mat4 cc_matProj;\nuniform mat4 cc_matProjInv;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matViewProjInv;\nuniform vec4 cc_cameraPos;\nuniform vec4 cc_exposure;\nuniform vec4 cc_mainLitDir;\nuniform vec4 cc_mainLitColor;\nuniform vec4 cc_ambientSky;\nuniform vec4 cc_ambientGround;\n#define SMAA_MAX_SEARCH_STEPS 8\n#define SMAA_AREATEX_MAX_DISTANCE 16\n#define SMAA_AREATEX_PIXEL_SIZE (1.0 / vec2(160.0, 560.0))\n#define SMAA_AREATEX_SUBTEX_SIZE (1.0 / 7.0)\nvarying vec2 v_uv;\nvarying vec4 v_offsets[3];\nvarying vec2 v_pixCoord;\nuniform sampler2D u_edgeTexSampler;\nuniform sampler2D u_areaTexSampler;\nuniform sampler2D u_searchTexSampler;\nfloat SMAASearchLength(vec2 e, float bias, float scale) {\n  e.r = bias + e.r * scale;\n  return 255.0 * texture2D(u_searchTexSampler, e).r;\n}\nfloat SMAASearchXLeft(vec2 texcoord, float end) {\n  vec2 e = vec2(0.0, 1.0);\n  for (int i = 0; i < 8; ++i) {\n      e = texture2D(u_edgeTexSampler, texcoord).rg;\n      texcoord -= vec2( 2.0, 0.0 ) * cc_nativeSize.zw;\n      if (!(texcoord.x > end && e.g > 0.8281 && e.r == 0.0))\n        break;\n  }\n  texcoord.x += 0.25 * cc_nativeSize.z;\n  texcoord.x += cc_nativeSize.z;\n  texcoord.x += 2.0 * cc_nativeSize.z;\n  texcoord.x -= cc_nativeSize.z * SMAASearchLength(e, 0.0, 0.5);\n  return texcoord.x;\n}\nfloat SMAASearchXRight(vec2 texcoord, float end) {\n  vec2 e = vec2(0.0, 1.0);\n  for (int i = 0; i < 8; ++i) {\n      e = texture2D(u_edgeTexSampler, texcoord).rg;\n      texcoord += vec2( 2.0, 0.0 ) * cc_nativeSize.zw;\n      if (!(texcoord.x < end && e.g > 0.8281 && e.r == 0.0))\n        break;\n  }\n  texcoord.x -= 0.25 * cc_nativeSize.z;\n  texcoord.x -= cc_nativeSize.z;\n  texcoord.x -= 2.0 * cc_nativeSize.z;\n  texcoord.x += cc_nativeSize.z * SMAASearchLength(e, 0.5, 0.5);\n  return texcoord.x;\n}\nfloat SMAASearchYUp(vec2 texcoord, float end) {\n    vec2 e = vec2(1.0, 0.0);\n    for (int i = 0; i < 8; ++i) {\n        e = texture2D(u_edgeTexSampler, texcoord).rg;\n        texcoord += vec2( 0.0, 2.0 ) * cc_nativeSize.zw;\n        if (!(texcoord.y > end && e.r > 0.8281 && e.g == 0.0))\n          break;\n    }\n    texcoord.y -= 0.25 * cc_nativeSize.w;\n    texcoord.y -= cc_nativeSize.w;\n    texcoord.y -= 2.0 * cc_nativeSize.w;\n    texcoord.y += cc_nativeSize.w * SMAASearchLength(e.gr, 0.0, 0.5);\n    return texcoord.y;\n}\nfloat SMAASearchYDown(vec2 texcoord, float end) {\n    vec2 e = vec2(1.0, 0.0);\n    for (int i = 0; i < 8; ++i) {\n        e = texture2D(u_edgeTexSampler, texcoord).rg;\n        texcoord -= vec2( 0.0, 2.0 ) * cc_nativeSize.zw;\n        if (!(texcoord.y < end && e.r > 0.8281 && e.g == 0.0))\n          break;\n    }\n    texcoord.y += 0.25 * cc_nativeSize.w;\n    texcoord.y += cc_nativeSize.w;\n    texcoord.y += 2.0 * cc_nativeSize.w;\n    texcoord.y -= cc_nativeSize.w * SMAASearchLength(e.gr, 0.5, 0.5);\n    return texcoord.y;\n}\nvec2 Round(vec2 x) {\n  return sign(x) * floor(abs(x) + 0.5);\n}\nvec2 SMAAArea(vec2 dist, float e1, float e2) {\n    vec2 texcoord = float(16) * Round(4.0 * vec2(e1, e2)) + dist;\n    texcoord = (1.0 / vec2(160.0, 560.0)) * texcoord + 0.5 * (1.0 / vec2(160.0, 560.0));\n    return texture2D(u_areaTexSampler, texcoord).rg;\n}\nvec4 frag () {\n  vec4 weights = vec4(0.0);\n  vec2 e = texture2D(u_edgeTexSampler, v_uv).rg;\n  vec2 d;\n  vec2 coords;\n  if ( e.g > 0.0 ) {\n      coords.x = SMAASearchXLeft(v_offsets[0].xy, v_offsets[2].x);\n      coords.y = v_offsets[1].y;\n      d.x = coords.x;\n      float e1 = texture2D(u_edgeTexSampler, coords).r;\n      coords.x = SMAASearchXRight(v_offsets[0].zw, v_offsets[2].y);\n      d.y = coords.x;\n      d = d / cc_nativeSize.z - v_pixCoord.x;\n      vec2 sqrt_d = sqrt(abs(d));\n      coords.y -= 1.0 * cc_nativeSize.w;\n      float e2 = texture2D(u_edgeTexSampler, coords + vec2(cc_nativeSize.z, 0.0)).r;\n      weights.rg = SMAAArea(sqrt_d, e1, e2);\n  }\n  if ( e.r > 0.0 ) {\n      coords.y = SMAASearchYUp(v_offsets[1].xy, v_offsets[2].z);\n      coords.x = v_offsets[0].x;\n      d.x = coords.y;\n      float e1 = texture2D(u_edgeTexSampler, coords).g;\n      coords.y = SMAASearchYDown(v_offsets[1].zw, v_offsets[2].w);\n      d.y = coords.y;\n      d = d / cc_nativeSize.w - v_pixCoord.y;\n      vec2 sqrt_d = sqrt(abs(d));\n      coords.y -= 1.0 * cc_nativeSize.w;\n      float e2 = texture2D(u_edgeTexSampler, coords + vec2(0.0, cc_nativeSize.w)).g;\n      weights.ba = SMAAArea(sqrt_d, e1, e2);\n  }\n  return weights;\n}\nvoid main() { gl_FragColor = frag(); }\n`
        },
        "builtins": {"globals":{"blocks":["CCGlobal"], "samplers":[]}, "locals":{"blocks":[], "samplers":[]}},
        "defines": [],
        "blocks": [],
        "samplers": [
          {"name":"u_edgeTexSampler", "type":28, "count":1, "defines":[], "binding":0},
          {"name":"u_areaTexSampler", "type":28, "count":1, "defines":[], "binding":1},
          {"name":"u_searchTexSampler", "type":28, "count":1, "defines":[], "binding":2}
        ],
        "dependencies": {}
      }
    ]
  },
  {
    "name": "pipeline/tonemap",
    "techniques": [
      {"name":"tonemap", "passes":[{"program":"pipeline/tonemap|tonemap-vs:vert|tonemap-fs:frag", "depthStencilState":{"depthTest":false, "depthWrite":false}, "properties":{"u_texSampler":{"sampler":[2, 2, null, 2, 2], "type":28}, "u_blendTexSampler":{"sampler":[2, 2, null, 2, 2], "type":28}}}]}
    ],
    "shaders": [
      {
        "name": "pipeline/tonemap|tonemap-vs:vert|tonemap-fs:frag",
        "hash": 1542908367,
        "glsl3": {
          "vert": `\nprecision highp float;\n#define PI 3.14159265359\n#define PI2 6.28318530718\n#define EPSILON 1e-6\n#define LOG2 1.442695\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define FP_MAX          65504.0\n#define FP_SCALE        0.0009765625\n#define FP_SCALE_INV    1024.0\nuniform CCGlobal {\n  vec4 cc_time; \n  vec4 cc_screenSize; \n  vec4 cc_screenScale; \n  vec4 cc_nativeSize; \n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos; \n  vec4 cc_exposure; \n  vec4 cc_mainLitDir; \n  vec4 cc_mainLitColor; \n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nin vec2 a_position;\nin vec2 a_texCoord;\nout vec2 v_uv;\nout vec4 v_offset;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 0, 1);\n  v_uv = a_texCoord * cc_screenScale.xy;\n  v_offset = v_uv.xyxy + cc_nativeSize.zwzw * vec4(1.0, 0.0, 0.0, -1.0);\n  return pos;\n}\nvoid main() { gl_Position = vert(); }\n`,
          "frag": `\nprecision highp float;\nuniform CCGlobal {\n  vec4 cc_time; \n  vec4 cc_screenSize; \n  vec4 cc_screenScale; \n  vec4 cc_nativeSize; \n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos; \n  vec4 cc_exposure; \n  vec4 cc_mainLitDir; \n  vec4 cc_mainLitColor; \n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\n#define PI 3.14159265359\n#define PI2 6.28318530718\n#define EPSILON 1e-6\n#define LOG2 1.442695\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define FP_MAX          65504.0\n#define FP_SCALE        0.0009765625\n#define FP_SCALE_INV    1024.0\nvec3 SRGBToLinear(vec3 gamma)\n{\n	return pow(gamma, vec3(2.2));\n	\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n	return pow(linear, vec3(0.454545));\n	\n}\nvec3 ACESToneMap(vec3 color) {\n    const float A = 2.51;\n    const float B = 0.03;\n    const float C = 2.43;\n    const float D = 0.59;\n    const float E = 0.14;\n    return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nin vec2 v_uv;\nin vec4 v_offset;\nuniform sampler2D u_texSampler;\nuniform sampler2D u_blendTexSampler;\nvec3 ToLDR(vec3 color) {\n#if CC_USE_HDR\n  color *= cc_exposure.x * 1024.0;\n  color = ACESToneMap(color);\n  color = LinearToSRGB(color);\n#else\n  color = SRGBToLinear(color);\n  color = ACESToneMap(color);\n  color = LinearToSRGB(color);\n#endif\n  return color;\n}\nvec4 frag () {\n#if CC_USE_SMAA\n  \n  vec4 a;\n  a.rb = texture(u_blendTexSampler, v_uv).rb; \n  a.g = texture(u_blendTexSampler, v_offset.zw).g; \n  a.a = texture(u_blendTexSampler, v_offset.xy).a; \n  if (dot(a, vec4(1.0)) < 1e-5) {\n    vec4 o = texture(u_texSampler, v_uv);\n    o.rgb = ToLDR(o.rgb);\n    return o;\n  } else {\n    vec2 offset;\n    offset.x = a.a > a.b ? a.a : -a.b;\n    offset.y = a.g > a.r ? -a.g : a.r;\n    if (abs(offset.x) > abs(offset.y)) {\n        offset.y = 0.0;\n    } else {\n        offset.x = 0.0;\n    }\n    vec4 C = texture(u_texSampler, v_uv);\n    C.rgb = ToLDR(C.rgb);\n    vec2 uv = v_uv + sign(offset) * cc_nativeSize.zw;\n    vec4 Cop = texture(u_texSampler, uv);\n    Cop.rgb = ToLDR(Cop.rgb);\n    float s = abs(offset.x) > abs(offset.y) ? abs(offset.x) : abs(offset.y);\n    C.rgb = pow(C.rgb, vec3(2.2));\n    Cop.rgb = pow(Cop.rgb, vec3(2.2));\n    vec4 mixed = mix(C, Cop, s);\n    mixed.rgb = pow(mixed.rgb, vec3(1.0 / 2.2));\n    return mixed;\n  }\n#else\n  vec4 o = texture(u_texSampler, v_uv);\n  \n  o.rgb = ToLDR(o.rgb);\n  return o;\n#endif\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }\n`
        },
        "glsl1": {
          "vert": `\nprecision highp float;\n#define PI 3.14159265359\n#define PI2 6.28318530718\n#define EPSILON 1e-6\n#define LOG2 1.442695\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define FP_MAX          65504.0\n#define FP_SCALE        0.0009765625\n#define FP_SCALE_INV    1024.0\nuniform vec4 cc_time;\nuniform vec4 cc_screenSize;\nuniform vec4 cc_screenScale;\nuniform vec4 cc_nativeSize;\nuniform mat4 cc_matView;\nuniform mat4 cc_matViewInv;\nuniform mat4 cc_matProj;\nuniform mat4 cc_matProjInv;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matViewProjInv;\nuniform vec4 cc_cameraPos;\nuniform vec4 cc_exposure;\nuniform vec4 cc_mainLitDir;\nuniform vec4 cc_mainLitColor;\nuniform vec4 cc_ambientSky;\nuniform vec4 cc_ambientGround;\nattribute vec2 a_position;\nattribute vec2 a_texCoord;\nvarying vec2 v_uv;\nvarying vec4 v_offset;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 0, 1);\n  v_uv = a_texCoord * cc_screenScale.xy;\n  v_offset = v_uv.xyxy + cc_nativeSize.zwzw * vec4(1.0, 0.0, 0.0, -1.0);\n  return pos;\n}\nvoid main() { gl_Position = vert(); }\n`,
          "frag": `\nprecision highp float;\nuniform vec4 cc_time;\nuniform vec4 cc_screenSize;\nuniform vec4 cc_screenScale;\nuniform vec4 cc_nativeSize;\nuniform mat4 cc_matView;\nuniform mat4 cc_matViewInv;\nuniform mat4 cc_matProj;\nuniform mat4 cc_matProjInv;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matViewProjInv;\nuniform vec4 cc_cameraPos;\nuniform vec4 cc_exposure;\nuniform vec4 cc_mainLitDir;\nuniform vec4 cc_mainLitColor;\nuniform vec4 cc_ambientSky;\nuniform vec4 cc_ambientGround;\n#define PI 3.14159265359\n#define PI2 6.28318530718\n#define EPSILON 1e-6\n#define LOG2 1.442695\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define FP_MAX          65504.0\n#define FP_SCALE        0.0009765625\n#define FP_SCALE_INV    1024.0\nvec3 SRGBToLinear(vec3 gamma)\n{\n	return pow(gamma, vec3(2.2));\n	\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n	return pow(linear, vec3(0.454545));\n	\n}\nvec3 ACESToneMap(vec3 color) {\n    const float A = 2.51;\n    const float B = 0.03;\n    const float C = 2.43;\n    const float D = 0.59;\n    const float E = 0.14;\n    return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvarying vec2 v_uv;\nvarying vec4 v_offset;\nuniform sampler2D u_texSampler;\nuniform sampler2D u_blendTexSampler;\nvec3 ToLDR(vec3 color) {\n#if CC_USE_HDR\n  color *= cc_exposure.x * 1024.0;\n  color = ACESToneMap(color);\n  color = LinearToSRGB(color);\n#else\n  color = SRGBToLinear(color);\n  color = ACESToneMap(color);\n  color = LinearToSRGB(color);\n#endif\n  return color;\n}\nvec4 frag () {\n#if CC_USE_SMAA\n  \n  vec4 a;\n  a.rb = texture2D(u_blendTexSampler, v_uv).rb; \n  a.g = texture2D(u_blendTexSampler, v_offset.zw).g; \n  a.a = texture2D(u_blendTexSampler, v_offset.xy).a; \n  if (dot(a, vec4(1.0)) < 1e-5) {\n    vec4 o = texture2D(u_texSampler, v_uv);\n    o.rgb = ToLDR(o.rgb);\n    return o;\n  } else {\n    vec2 offset;\n    offset.x = a.a > a.b ? a.a : -a.b;\n    offset.y = a.g > a.r ? -a.g : a.r;\n    if (abs(offset.x) > abs(offset.y)) {\n        offset.y = 0.0;\n    } else {\n        offset.x = 0.0;\n    }\n    vec4 C = texture2D(u_texSampler, v_uv);\n    C.rgb = ToLDR(C.rgb);\n    vec2 uv = v_uv + sign(offset) * cc_nativeSize.zw;\n    vec4 Cop = texture2D(u_texSampler, uv);\n    Cop.rgb = ToLDR(Cop.rgb);\n    float s = abs(offset.x) > abs(offset.y) ? abs(offset.x) : abs(offset.y);\n    C.rgb = pow(C.rgb, vec3(2.2));\n    Cop.rgb = pow(Cop.rgb, vec3(2.2));\n    vec4 mixed = mix(C, Cop, s);\n    mixed.rgb = pow(mixed.rgb, vec3(1.0 / 2.2));\n    return mixed;\n  }\n#else\n  vec4 o = texture2D(u_texSampler, v_uv);\n  \n  o.rgb = ToLDR(o.rgb);\n  return o;\n#endif\n}\nvoid main() { gl_FragColor = frag(); }\n`
        },
        "builtins": {"globals":{"blocks":["CCGlobal"], "samplers":[]}, "locals":{"blocks":[], "samplers":[]}},
        "defines": [
          {"name":"CC_USE_HDR", "type":"boolean", "defines":[]},
          {"name":"CC_USE_SMAA", "type":"boolean", "defines":[]}
        ],
        "blocks": [],
        "samplers": [
          {"name":"u_texSampler", "type":28, "count":1, "defines":[], "binding":0},
          {"name":"u_blendTexSampler", "type":28, "count":1, "defines":[], "binding":1}
        ],
        "dependencies": {}
      }
    ]
  }
];
